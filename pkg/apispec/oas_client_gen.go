// Code generated by ogen, DO NOT EDIT.

package apispec

import (
	"context"
	"net/http"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

type requestConfig struct {
	Client       ht.Client
	ServerURL    *url.URL
	EditRequest  func(req *http.Request) error
	EditResponse func(resp *http.Response) error
}

func (cfg *requestConfig) setDefaults(c baseClient) {
	if cfg.Client == nil {
		cfg.Client = c.cfg.Client
	}
}

func (cfg *requestConfig) onRequest(req *http.Request) error {
	if fn := cfg.EditRequest; fn != nil {
		return fn(req)
	}
	return nil
}

func (cfg *requestConfig) onResponse(resp *http.Response) error {
	if fn := cfg.EditResponse; fn != nil {
		return fn(resp)
	}
	return nil
}

// RequestOption defines options for request.
type RequestOption func(cfg *requestConfig)

// WithRequestClient sets client for request.
func WithRequestClient(client ht.Client) RequestOption {
	return func(cfg *requestConfig) {
		cfg.Client = client
	}
}

// WithServerURL sets client for request.
func WithServerURL(u *url.URL) RequestOption {
	return func(cfg *requestConfig) {
		cfg.ServerURL = u
	}
}

// WithEditRequest sets function to edit request.
func WithEditRequest(fn func(req *http.Request) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditRequest = fn
	}
}

// WithEditResponse sets function to edit response.
func WithEditResponse(fn func(resp *http.Response) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditResponse = fn
	}
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// APIKeysGet invokes GET /api-keys operation.
	//
	// List API keys.
	//
	// GET /api-keys
	APIKeysGet(ctx context.Context, options ...RequestOption) (APIKeysGetRes, error)
	// APIKeysIDDeactivatePost invokes POST /api-keys/{id}/deactivate operation.
	//
	// Deactivate API key.
	//
	// POST /api-keys/{id}/deactivate
	APIKeysIDDeactivatePost(ctx context.Context, params APIKeysIDDeactivatePostParams, options ...RequestOption) (APIKeysIDDeactivatePostRes, error)
	// APIKeysIDDelete invokes DELETE /api-keys/{id} operation.
	//
	// Delete API key.
	//
	// DELETE /api-keys/{id}
	APIKeysIDDelete(ctx context.Context, params APIKeysIDDeleteParams, options ...RequestOption) (APIKeysIDDeleteRes, error)
	// APIKeysPost invokes POST /api-keys operation.
	//
	// Create API key.
	//
	// POST /api-keys
	APIKeysPost(ctx context.Context, request *CreateAPIKeyRequest, options ...RequestOption) (APIKeysPostRes, error)
	// APIV1RegistryCredentialsPost invokes POST /api/v1/registry/credentials operation.
	//
	// Get registry credentials for uploads.
	//
	// POST /api/v1/registry/credentials
	APIV1RegistryCredentialsPost(ctx context.Context, options ...RequestOption) (APIV1RegistryCredentialsPostRes, error)
	// APIV1SandboxesIDContextsCtxIDDelete invokes DELETE /api/v1/sandboxes/{id}/contexts/{ctx_id} operation.
	//
	// Delete context.
	//
	// DELETE /api/v1/sandboxes/{id}/contexts/{ctx_id}
	APIV1SandboxesIDContextsCtxIDDelete(ctx context.Context, params APIV1SandboxesIDContextsCtxIDDeleteParams, options ...RequestOption) (*SuccessDeletedResponse, error)
	// APIV1SandboxesIDContextsCtxIDExecPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/exec operation.
	//
	// Sends input and blocks until the context completes or times out.
	//
	// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/exec
	APIV1SandboxesIDContextsCtxIDExecPost(ctx context.Context, request *ContextInputRequest, params APIV1SandboxesIDContextsCtxIDExecPostParams, options ...RequestOption) (*SuccessContextExecResponse, error)
	// APIV1SandboxesIDContextsCtxIDGet invokes GET /api/v1/sandboxes/{id}/contexts/{ctx_id} operation.
	//
	// Get context.
	//
	// GET /api/v1/sandboxes/{id}/contexts/{ctx_id}
	APIV1SandboxesIDContextsCtxIDGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDGetParams, options ...RequestOption) (*SuccessContextResponse, error)
	// APIV1SandboxesIDContextsCtxIDInputPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/input operation.
	//
	// Send input to context.
	//
	// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/input
	APIV1SandboxesIDContextsCtxIDInputPost(ctx context.Context, request *ContextInputRequest, params APIV1SandboxesIDContextsCtxIDInputPostParams, options ...RequestOption) (*SuccessWrittenResponse, error)
	// APIV1SandboxesIDContextsCtxIDResizePost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/resize operation.
	//
	// Resize context PTY.
	//
	// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/resize
	APIV1SandboxesIDContextsCtxIDResizePost(ctx context.Context, request *ResizeContextRequest, params APIV1SandboxesIDContextsCtxIDResizePostParams, options ...RequestOption) (*SuccessResizedResponse, error)
	// APIV1SandboxesIDContextsCtxIDRestartPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/restart operation.
	//
	// Restart context.
	//
	// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/restart
	APIV1SandboxesIDContextsCtxIDRestartPost(ctx context.Context, params APIV1SandboxesIDContextsCtxIDRestartPostParams, options ...RequestOption) (*SuccessContextResponse, error)
	// APIV1SandboxesIDContextsCtxIDSignalPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/signal operation.
	//
	// Send signal to context.
	//
	// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/signal
	APIV1SandboxesIDContextsCtxIDSignalPost(ctx context.Context, request *SignalContextRequest, params APIV1SandboxesIDContextsCtxIDSignalPostParams, options ...RequestOption) (*SuccessSignaledResponse, error)
	// APIV1SandboxesIDContextsCtxIDStatsGet invokes GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/stats operation.
	//
	// Get context stats.
	//
	// GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/stats
	APIV1SandboxesIDContextsCtxIDStatsGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDStatsGetParams, options ...RequestOption) (*SuccessContextStatsResponse, error)
	// APIV1SandboxesIDContextsCtxIDWsGet invokes GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/ws operation.
	//
	// Upgrades to WebSocket for streaming I/O.
	// Client messages (JSON):
	// - { "type": "input", "data": "ls\n", "request_id": "req-1" }
	// - { "type": "resize", "rows": 24, "cols": 80 }
	// - { "type": "signal", "signal": "INT" }
	// Server messages (JSON):
	// - { "type": "output", "source": "stdout", "data": "hello\n" }.
	//
	// GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/ws
	APIV1SandboxesIDContextsCtxIDWsGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDWsGetParams, options ...RequestOption) error
	// APIV1SandboxesIDContextsGet invokes GET /api/v1/sandboxes/{id}/contexts operation.
	//
	// List contexts.
	//
	// GET /api/v1/sandboxes/{id}/contexts
	APIV1SandboxesIDContextsGet(ctx context.Context, params APIV1SandboxesIDContextsGetParams, options ...RequestOption) (*SuccessContextListResponse, error)
	// APIV1SandboxesIDContextsPost invokes POST /api/v1/sandboxes/{id}/contexts operation.
	//
	// Create a context.
	//
	// POST /api/v1/sandboxes/{id}/contexts
	APIV1SandboxesIDContextsPost(ctx context.Context, request *CreateContextRequest, params APIV1SandboxesIDContextsPostParams, options ...RequestOption) (*SuccessContextResponse, error)
	// APIV1SandboxesIDDelete invokes DELETE /api/v1/sandboxes/{id} operation.
	//
	// Delete (terminate) a sandbox.
	//
	// DELETE /api/v1/sandboxes/{id}
	APIV1SandboxesIDDelete(ctx context.Context, params APIV1SandboxesIDDeleteParams, options ...RequestOption) (APIV1SandboxesIDDeleteRes, error)
	// APIV1SandboxesIDFilesDelete invokes DELETE /api/v1/sandboxes/{id}/files operation.
	//
	// Delete file or directory.
	//
	// DELETE /api/v1/sandboxes/{id}/files
	APIV1SandboxesIDFilesDelete(ctx context.Context, params APIV1SandboxesIDFilesDeleteParams, options ...RequestOption) (*SuccessDeletedResponse, error)
	// APIV1SandboxesIDFilesGet invokes GET /api/v1/sandboxes/{id}/files operation.
	//
	// Use query params:
	// - path=/tmp/a.txt: target file path
	// When `Accept` or `Content-Type` is `application/json`, returns a base64 JSON payload.
	//
	// GET /api/v1/sandboxes/{id}/files
	APIV1SandboxesIDFilesGet(ctx context.Context, params APIV1SandboxesIDFilesGetParams, options ...RequestOption) (APIV1SandboxesIDFilesGetRes, error)
	// APIV1SandboxesIDFilesListGet invokes GET /api/v1/sandboxes/{id}/files/list operation.
	//
	// Use query params:
	// - path=/tmp: target directory path.
	//
	// GET /api/v1/sandboxes/{id}/files/list
	APIV1SandboxesIDFilesListGet(ctx context.Context, params APIV1SandboxesIDFilesListGetParams, options ...RequestOption) (*SuccessFileListResponse, error)
	// APIV1SandboxesIDFilesMovePost invokes POST /api/v1/sandboxes/{id}/files/move operation.
	//
	// Move a file or directory.
	//
	// POST /api/v1/sandboxes/{id}/files/move
	APIV1SandboxesIDFilesMovePost(ctx context.Context, request *MoveFileRequest, params APIV1SandboxesIDFilesMovePostParams, options ...RequestOption) (*SuccessMovedResponse, error)
	// APIV1SandboxesIDFilesPost invokes POST /api/v1/sandboxes/{id}/files operation.
	//
	// Use `path` query param and `mkdir=true` to create directories, otherwise writes file content.
	//
	// POST /api/v1/sandboxes/{id}/files
	APIV1SandboxesIDFilesPost(ctx context.Context, request APIV1SandboxesIDFilesPostReq, params APIV1SandboxesIDFilesPostParams, options ...RequestOption) (APIV1SandboxesIDFilesPostRes, error)
	// APIV1SandboxesIDFilesStatGet invokes GET /api/v1/sandboxes/{id}/files/stat operation.
	//
	// Use query params:
	// - path=/tmp/a.txt: target file path.
	//
	// GET /api/v1/sandboxes/{id}/files/stat
	APIV1SandboxesIDFilesStatGet(ctx context.Context, params APIV1SandboxesIDFilesStatGetParams, options ...RequestOption) (*SuccessFileStatResponse, error)
	// APIV1SandboxesIDFilesWatchGet invokes GET /api/v1/sandboxes/{id}/files/watch operation.
	//
	// Upgrades to WebSocket for file watch events.
	// Client messages:
	// - { "action": "subscribe", "path": "/tmp", "recursive": false }
	// - { "action": "unsubscribe", "watch_id": "watch-id" }
	// Server messages:
	// - { "type": "subscribed", "watch_id": "watch-id", "path": "/tmp" }
	// - { "type": "event", "watch_id": "watch-id", "event": "write", "path": "/tmp/a.txt" }
	// - { "type": "unsubscribed", "watch_id": "watch-id" }
	// - { "type": "error", "error": "message" }.
	//
	// GET /api/v1/sandboxes/{id}/files/watch
	APIV1SandboxesIDFilesWatchGet(ctx context.Context, params APIV1SandboxesIDFilesWatchGetParams, options ...RequestOption) error
	// APIV1SandboxesIDGet invokes GET /api/v1/sandboxes/{id} operation.
	//
	// Get sandbox by ID.
	//
	// GET /api/v1/sandboxes/{id}
	APIV1SandboxesIDGet(ctx context.Context, params APIV1SandboxesIDGetParams, options ...RequestOption) (APIV1SandboxesIDGetRes, error)
	// APIV1SandboxesIDNetworkGet invokes GET /api/v1/sandboxes/{id}/network operation.
	//
	// Get sandbox network policy.
	//
	// GET /api/v1/sandboxes/{id}/network
	APIV1SandboxesIDNetworkGet(ctx context.Context, params APIV1SandboxesIDNetworkGetParams, options ...RequestOption) (APIV1SandboxesIDNetworkGetRes, error)
	// APIV1SandboxesIDNetworkPatch invokes PATCH /api/v1/sandboxes/{id}/network operation.
	//
	// Update sandbox network policy.
	//
	// PATCH /api/v1/sandboxes/{id}/network
	APIV1SandboxesIDNetworkPatch(ctx context.Context, request *TplSandboxNetworkPolicy, params APIV1SandboxesIDNetworkPatchParams, options ...RequestOption) (*SuccessSandboxNetworkPolicyResponse, error)
	// APIV1SandboxesIDPatch invokes PATCH /api/v1/sandboxes/{id} operation.
	//
	// Update sandbox configuration.
	//
	// PATCH /api/v1/sandboxes/{id}
	APIV1SandboxesIDPatch(ctx context.Context, request *SandboxUpdateRequest, params APIV1SandboxesIDPatchParams, options ...RequestOption) (APIV1SandboxesIDPatchRes, error)
	// APIV1SandboxesIDPausePost invokes POST /api/v1/sandboxes/{id}/pause operation.
	//
	// Pause a sandbox.
	//
	// POST /api/v1/sandboxes/{id}/pause
	APIV1SandboxesIDPausePost(ctx context.Context, params APIV1SandboxesIDPausePostParams, options ...RequestOption) (APIV1SandboxesIDPausePostRes, error)
	// APIV1SandboxesIDRefreshPost invokes POST /api/v1/sandboxes/{id}/refresh operation.
	//
	// Refresh sandbox TTL.
	//
	// POST /api/v1/sandboxes/{id}/refresh
	APIV1SandboxesIDRefreshPost(ctx context.Context, request OptRefreshRequest, params APIV1SandboxesIDRefreshPostParams, options ...RequestOption) (APIV1SandboxesIDRefreshPostRes, error)
	// APIV1SandboxesIDResumePost invokes POST /api/v1/sandboxes/{id}/resume operation.
	//
	// Resume a sandbox.
	//
	// POST /api/v1/sandboxes/{id}/resume
	APIV1SandboxesIDResumePost(ctx context.Context, params APIV1SandboxesIDResumePostParams, options ...RequestOption) (APIV1SandboxesIDResumePostRes, error)
	// APIV1SandboxesIDSandboxvolumesMountPost invokes POST /api/v1/sandboxes/{id}/sandboxvolumes/mount operation.
	//
	// Mount sandbox volume in sandbox.
	//
	// POST /api/v1/sandboxes/{id}/sandboxvolumes/mount
	APIV1SandboxesIDSandboxvolumesMountPost(ctx context.Context, request *MountRequest, params APIV1SandboxesIDSandboxvolumesMountPostParams, options ...RequestOption) (*SuccessMountResponse, error)
	// APIV1SandboxesIDSandboxvolumesStatusGet invokes GET /api/v1/sandboxes/{id}/sandboxvolumes/status operation.
	//
	// Get sandbox volume mount status.
	//
	// GET /api/v1/sandboxes/{id}/sandboxvolumes/status
	APIV1SandboxesIDSandboxvolumesStatusGet(ctx context.Context, params APIV1SandboxesIDSandboxvolumesStatusGetParams, options ...RequestOption) (*SuccessMountStatusResponse, error)
	// APIV1SandboxesIDSandboxvolumesUnmountPost invokes POST /api/v1/sandboxes/{id}/sandboxvolumes/unmount operation.
	//
	// Unmount sandbox volume.
	//
	// POST /api/v1/sandboxes/{id}/sandboxvolumes/unmount
	APIV1SandboxesIDSandboxvolumesUnmountPost(ctx context.Context, request *UnmountRequest, params APIV1SandboxesIDSandboxvolumesUnmountPostParams, options ...RequestOption) (*SuccessUnmountedResponse, error)
	// APIV1SandboxesIDStatusGet invokes GET /api/v1/sandboxes/{id}/status operation.
	//
	// Get sandbox status.
	//
	// GET /api/v1/sandboxes/{id}/status
	APIV1SandboxesIDStatusGet(ctx context.Context, params APIV1SandboxesIDStatusGetParams, options ...RequestOption) (APIV1SandboxesIDStatusGetRes, error)
	// APIV1SandboxesPost invokes POST /api/v1/sandboxes operation.
	//
	// Create (claim) a sandbox.
	//
	// POST /api/v1/sandboxes
	APIV1SandboxesPost(ctx context.Context, request *ClaimRequest, options ...RequestOption) (APIV1SandboxesPostRes, error)
	// APIV1SandboxvolumesGet invokes GET /api/v1/sandboxvolumes operation.
	//
	// List sandbox volumes.
	//
	// GET /api/v1/sandboxvolumes
	APIV1SandboxvolumesGet(ctx context.Context, options ...RequestOption) (*SuccessSandboxVolumeListResponse, error)
	// APIV1SandboxvolumesIDDelete invokes DELETE /api/v1/sandboxvolumes/{id} operation.
	//
	// Delete sandbox volume.
	//
	// DELETE /api/v1/sandboxvolumes/{id}
	APIV1SandboxvolumesIDDelete(ctx context.Context, params APIV1SandboxvolumesIDDeleteParams, options ...RequestOption) (APIV1SandboxvolumesIDDeleteRes, error)
	// APIV1SandboxvolumesIDGet invokes GET /api/v1/sandboxvolumes/{id} operation.
	//
	// Get sandbox volume.
	//
	// GET /api/v1/sandboxvolumes/{id}
	APIV1SandboxvolumesIDGet(ctx context.Context, params APIV1SandboxvolumesIDGetParams, options ...RequestOption) (APIV1SandboxvolumesIDGetRes, error)
	// APIV1SandboxvolumesIDSnapshotsGet invokes GET /api/v1/sandboxvolumes/{id}/snapshots operation.
	//
	// List snapshots.
	//
	// GET /api/v1/sandboxvolumes/{id}/snapshots
	APIV1SandboxvolumesIDSnapshotsGet(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsGetParams, options ...RequestOption) (*SuccessSnapshotListResponse, error)
	// APIV1SandboxvolumesIDSnapshotsPost invokes POST /api/v1/sandboxvolumes/{id}/snapshots operation.
	//
	// Create snapshot.
	//
	// POST /api/v1/sandboxvolumes/{id}/snapshots
	APIV1SandboxvolumesIDSnapshotsPost(ctx context.Context, request *CreateSnapshotRequest, params APIV1SandboxvolumesIDSnapshotsPostParams, options ...RequestOption) (*SuccessSnapshotResponse, error)
	// APIV1SandboxvolumesIDSnapshotsSnapshotIDDelete invokes DELETE /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id} operation.
	//
	// Delete snapshot.
	//
	// DELETE /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}
	APIV1SandboxvolumesIDSnapshotsSnapshotIDDelete(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDDeleteParams, options ...RequestOption) (*SuccessDeletedResponse, error)
	// APIV1SandboxvolumesIDSnapshotsSnapshotIDGet invokes GET /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id} operation.
	//
	// Get snapshot.
	//
	// GET /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}
	APIV1SandboxvolumesIDSnapshotsSnapshotIDGet(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDGetParams, options ...RequestOption) (APIV1SandboxvolumesIDSnapshotsSnapshotIDGetRes, error)
	// APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePost invokes POST /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}/restore operation.
	//
	// Restore snapshot.
	//
	// POST /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}/restore
	APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePost(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePostParams, options ...RequestOption) (*SuccessRestoreResponse, error)
	// APIV1SandboxvolumesPost invokes POST /api/v1/sandboxvolumes operation.
	//
	// Create sandbox volume.
	//
	// POST /api/v1/sandboxvolumes
	APIV1SandboxvolumesPost(ctx context.Context, request *CreateSandboxVolumeRequest, options ...RequestOption) (*SuccessSandboxVolumeResponse, error)
	// APIV1TemplatesGet invokes GET /api/v1/templates operation.
	//
	// List templates.
	//
	// GET /api/v1/templates
	APIV1TemplatesGet(ctx context.Context, options ...RequestOption) (*SuccessTemplateListResponse, error)
	// APIV1TemplatesIDDelete invokes DELETE /api/v1/templates/{id} operation.
	//
	// Delete template.
	//
	// DELETE /api/v1/templates/{id}
	APIV1TemplatesIDDelete(ctx context.Context, params APIV1TemplatesIDDeleteParams, options ...RequestOption) (*SuccessMessageResponse, error)
	// APIV1TemplatesIDGet invokes GET /api/v1/templates/{id} operation.
	//
	// Get template.
	//
	// GET /api/v1/templates/{id}
	APIV1TemplatesIDGet(ctx context.Context, params APIV1TemplatesIDGetParams, options ...RequestOption) (APIV1TemplatesIDGetRes, error)
	// APIV1TemplatesIDPut invokes PUT /api/v1/templates/{id} operation.
	//
	// Update template.
	//
	// PUT /api/v1/templates/{id}
	APIV1TemplatesIDPut(ctx context.Context, request *TemplateUpdateRequest, params APIV1TemplatesIDPutParams, options ...RequestOption) (*SuccessTemplateResponse, error)
	// APIV1TemplatesPost invokes POST /api/v1/templates operation.
	//
	// Create template.
	//
	// POST /api/v1/templates
	APIV1TemplatesPost(ctx context.Context, request *TemplateCreateRequest, options ...RequestOption) (*SuccessTemplateResponse, error)
	// AuthChangePasswordPost invokes POST /auth/change-password operation.
	//
	// Change password.
	//
	// POST /auth/change-password
	AuthChangePasswordPost(ctx context.Context, request *ChangePasswordRequest, options ...RequestOption) (AuthChangePasswordPostRes, error)
	// AuthLoginPost invokes POST /auth/login operation.
	//
	// Login with email and password.
	//
	// POST /auth/login
	AuthLoginPost(ctx context.Context, request *LoginRequest, options ...RequestOption) (AuthLoginPostRes, error)
	// AuthLogoutPost invokes POST /auth/logout operation.
	//
	// Logout.
	//
	// POST /auth/logout
	AuthLogoutPost(ctx context.Context, options ...RequestOption) (*SuccessMessageResponse, error)
	// AuthOidcProviderCallbackGet invokes GET /auth/oidc/{provider}/callback operation.
	//
	// OIDC callback.
	//
	// GET /auth/oidc/{provider}/callback
	AuthOidcProviderCallbackGet(ctx context.Context, params AuthOidcProviderCallbackGetParams, options ...RequestOption) (AuthOidcProviderCallbackGetRes, error)
	// AuthOidcProviderLoginGet invokes GET /auth/oidc/{provider}/login operation.
	//
	// Initiate OIDC login.
	//
	// GET /auth/oidc/{provider}/login
	AuthOidcProviderLoginGet(ctx context.Context, params AuthOidcProviderLoginGetParams, options ...RequestOption) (AuthOidcProviderLoginGetRes, error)
	// AuthProvidersGet invokes GET /auth/providers operation.
	//
	// Get available auth providers.
	//
	// GET /auth/providers
	AuthProvidersGet(ctx context.Context, options ...RequestOption) (AuthProvidersGetRes, error)
	// AuthRefreshPost invokes POST /auth/refresh operation.
	//
	// Refresh access token.
	//
	// POST /auth/refresh
	AuthRefreshPost(ctx context.Context, request *RefreshRequest, options ...RequestOption) (AuthRefreshPostRes, error)
	// AuthRegisterPost invokes POST /auth/register operation.
	//
	// Register a new user.
	//
	// POST /auth/register
	AuthRegisterPost(ctx context.Context, request *RegisterRequest, options ...RequestOption) (AuthRegisterPostRes, error)
	// HealthzGet invokes GET /healthz operation.
	//
	// Health check.
	//
	// GET /healthz
	HealthzGet(ctx context.Context, options ...RequestOption) (HealthzGetRes, error)
	// MetricsGet invokes GET /metrics operation.
	//
	// Prometheus metrics.
	//
	// GET /metrics
	MetricsGet(ctx context.Context, options ...RequestOption) (MetricsGetOK, error)
	// ReadyzGet invokes GET /readyz operation.
	//
	// Readiness check.
	//
	// GET /readyz
	ReadyzGet(ctx context.Context, options ...RequestOption) (ReadyzGetRes, error)
	// TeamsGet invokes GET /teams operation.
	//
	// List teams.
	//
	// GET /teams
	TeamsGet(ctx context.Context, options ...RequestOption) (TeamsGetRes, error)
	// TeamsIDDelete invokes DELETE /teams/{id} operation.
	//
	// Delete a team.
	//
	// DELETE /teams/{id}
	TeamsIDDelete(ctx context.Context, params TeamsIDDeleteParams, options ...RequestOption) (TeamsIDDeleteRes, error)
	// TeamsIDGet invokes GET /teams/{id} operation.
	//
	// Get a team.
	//
	// GET /teams/{id}
	TeamsIDGet(ctx context.Context, params TeamsIDGetParams, options ...RequestOption) (TeamsIDGetRes, error)
	// TeamsIDMembersGet invokes GET /teams/{id}/members operation.
	//
	// List team members.
	//
	// GET /teams/{id}/members
	TeamsIDMembersGet(ctx context.Context, params TeamsIDMembersGetParams, options ...RequestOption) (TeamsIDMembersGetRes, error)
	// TeamsIDMembersPost invokes POST /teams/{id}/members operation.
	//
	// Add team member.
	//
	// POST /teams/{id}/members
	TeamsIDMembersPost(ctx context.Context, request *AddTeamMemberRequest, params TeamsIDMembersPostParams, options ...RequestOption) (TeamsIDMembersPostRes, error)
	// TeamsIDMembersUserIdDelete invokes DELETE /teams/{id}/members/{userId} operation.
	//
	// Remove team member.
	//
	// DELETE /teams/{id}/members/{userId}
	TeamsIDMembersUserIdDelete(ctx context.Context, params TeamsIDMembersUserIdDeleteParams, options ...RequestOption) (TeamsIDMembersUserIdDeleteRes, error)
	// TeamsIDMembersUserIdPut invokes PUT /teams/{id}/members/{userId} operation.
	//
	// Update team member role.
	//
	// PUT /teams/{id}/members/{userId}
	TeamsIDMembersUserIdPut(ctx context.Context, request *UpdateTeamMemberRequest, params TeamsIDMembersUserIdPutParams, options ...RequestOption) (TeamsIDMembersUserIdPutRes, error)
	// TeamsIDPut invokes PUT /teams/{id} operation.
	//
	// Update a team.
	//
	// PUT /teams/{id}
	TeamsIDPut(ctx context.Context, request *UpdateTeamRequest, params TeamsIDPutParams, options ...RequestOption) (TeamsIDPutRes, error)
	// TeamsPost invokes POST /teams operation.
	//
	// Create a team.
	//
	// POST /teams
	TeamsPost(ctx context.Context, request *CreateTeamRequest, options ...RequestOption) (TeamsPostRes, error)
	// UsersMeGet invokes GET /users/me operation.
	//
	// Get current user.
	//
	// GET /users/me
	UsersMeGet(ctx context.Context, options ...RequestOption) (UsersMeGetRes, error)
	// UsersMeIdentitiesGet invokes GET /users/me/identities operation.
	//
	// List current user identities.
	//
	// GET /users/me/identities
	UsersMeIdentitiesGet(ctx context.Context, options ...RequestOption) (UsersMeIdentitiesGetRes, error)
	// UsersMeIdentitiesIDDelete invokes DELETE /users/me/identities/{id} operation.
	//
	// Delete a user identity.
	//
	// DELETE /users/me/identities/{id}
	UsersMeIdentitiesIDDelete(ctx context.Context, params UsersMeIdentitiesIDDeleteParams, options ...RequestOption) (UsersMeIdentitiesIDDeleteRes, error)
	// UsersMePut invokes PUT /users/me operation.
	//
	// Update current user.
	//
	// PUT /users/me
	UsersMePut(ctx context.Context, request *UpdateUserRequest, options ...RequestOption) (UsersMePutRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}
func (c *Client) onRequest(ctx context.Context, req *http.Request) error {
	for _, fn := range c.cfg.RequestEditors {
		if err := fn(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) onResponse(ctx context.Context, resp *http.Response) error {
	for _, fn := range c.cfg.ResponseEditors {
		if err := fn(ctx, resp); err != nil {
			return err
		}
	}
	return nil
}

// APIKeysGet invokes GET /api-keys operation.
//
// List API keys.
//
// GET /api-keys
func (c *Client) APIKeysGet(ctx context.Context, options ...RequestOption) (APIKeysGetRes, error) {
	res, err := c.sendAPIKeysGet(ctx, options...)
	return res, err
}

func (c *Client) sendAPIKeysGet(ctx context.Context, requestOptions ...RequestOption) (res APIKeysGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIKeysGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIKeysGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIKeysIDDeactivatePost invokes POST /api-keys/{id}/deactivate operation.
//
// Deactivate API key.
//
// POST /api-keys/{id}/deactivate
func (c *Client) APIKeysIDDeactivatePost(ctx context.Context, params APIKeysIDDeactivatePostParams, options ...RequestOption) (APIKeysIDDeactivatePostRes, error) {
	res, err := c.sendAPIKeysIDDeactivatePost(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIKeysIDDeactivatePost(ctx context.Context, params APIKeysIDDeactivatePostParams, requestOptions ...RequestOption) (res APIKeysIDDeactivatePostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/deactivate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIKeysIDDeactivatePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIKeysIDDeactivatePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIKeysIDDelete invokes DELETE /api-keys/{id} operation.
//
// Delete API key.
//
// DELETE /api-keys/{id}
func (c *Client) APIKeysIDDelete(ctx context.Context, params APIKeysIDDeleteParams, options ...RequestOption) (APIKeysIDDeleteRes, error) {
	res, err := c.sendAPIKeysIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIKeysIDDelete(ctx context.Context, params APIKeysIDDeleteParams, requestOptions ...RequestOption) (res APIKeysIDDeleteRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api-keys/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIKeysIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIKeysIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIKeysPost invokes POST /api-keys operation.
//
// Create API key.
//
// POST /api-keys
func (c *Client) APIKeysPost(ctx context.Context, request *CreateAPIKeyRequest, options ...RequestOption) (APIKeysPostRes, error) {
	res, err := c.sendAPIKeysPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAPIKeysPost(ctx context.Context, request *CreateAPIKeyRequest, requestOptions ...RequestOption) (res APIKeysPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIKeysPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIKeysPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIKeysPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1RegistryCredentialsPost invokes POST /api/v1/registry/credentials operation.
//
// Get registry credentials for uploads.
//
// POST /api/v1/registry/credentials
func (c *Client) APIV1RegistryCredentialsPost(ctx context.Context, options ...RequestOption) (APIV1RegistryCredentialsPostRes, error) {
	res, err := c.sendAPIV1RegistryCredentialsPost(ctx, options...)
	return res, err
}

func (c *Client) sendAPIV1RegistryCredentialsPost(ctx context.Context, requestOptions ...RequestOption) (res APIV1RegistryCredentialsPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/v1/registry/credentials"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1RegistryCredentialsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1RegistryCredentialsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDDelete invokes DELETE /api/v1/sandboxes/{id}/contexts/{ctx_id} operation.
//
// Delete context.
//
// DELETE /api/v1/sandboxes/{id}/contexts/{ctx_id}
func (c *Client) APIV1SandboxesIDContextsCtxIDDelete(ctx context.Context, params APIV1SandboxesIDContextsCtxIDDeleteParams, options ...RequestOption) (*SuccessDeletedResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDDelete(ctx context.Context, params APIV1SandboxesIDContextsCtxIDDeleteParams, requestOptions ...RequestOption) (res *SuccessDeletedResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDExecPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/exec operation.
//
// Sends input and blocks until the context completes or times out.
//
// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/exec
func (c *Client) APIV1SandboxesIDContextsCtxIDExecPost(ctx context.Context, request *ContextInputRequest, params APIV1SandboxesIDContextsCtxIDExecPostParams, options ...RequestOption) (*SuccessContextExecResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDExecPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDExecPost(ctx context.Context, request *ContextInputRequest, params APIV1SandboxesIDContextsCtxIDExecPostParams, requestOptions ...RequestOption) (res *SuccessContextExecResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/exec"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDContextsCtxIDExecPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDExecPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDExecPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDGet invokes GET /api/v1/sandboxes/{id}/contexts/{ctx_id} operation.
//
// Get context.
//
// GET /api/v1/sandboxes/{id}/contexts/{ctx_id}
func (c *Client) APIV1SandboxesIDContextsCtxIDGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDGetParams, options ...RequestOption) (*SuccessContextResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDGetParams, requestOptions ...RequestOption) (res *SuccessContextResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDInputPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/input operation.
//
// Send input to context.
//
// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/input
func (c *Client) APIV1SandboxesIDContextsCtxIDInputPost(ctx context.Context, request *ContextInputRequest, params APIV1SandboxesIDContextsCtxIDInputPostParams, options ...RequestOption) (*SuccessWrittenResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDInputPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDInputPost(ctx context.Context, request *ContextInputRequest, params APIV1SandboxesIDContextsCtxIDInputPostParams, requestOptions ...RequestOption) (res *SuccessWrittenResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/input"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDContextsCtxIDInputPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDInputPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDInputPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDResizePost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/resize operation.
//
// Resize context PTY.
//
// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/resize
func (c *Client) APIV1SandboxesIDContextsCtxIDResizePost(ctx context.Context, request *ResizeContextRequest, params APIV1SandboxesIDContextsCtxIDResizePostParams, options ...RequestOption) (*SuccessResizedResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDResizePost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDResizePost(ctx context.Context, request *ResizeContextRequest, params APIV1SandboxesIDContextsCtxIDResizePostParams, requestOptions ...RequestOption) (res *SuccessResizedResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/resize"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDContextsCtxIDResizePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDResizePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDResizePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDRestartPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/restart operation.
//
// Restart context.
//
// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/restart
func (c *Client) APIV1SandboxesIDContextsCtxIDRestartPost(ctx context.Context, params APIV1SandboxesIDContextsCtxIDRestartPostParams, options ...RequestOption) (*SuccessContextResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDRestartPost(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDRestartPost(ctx context.Context, params APIV1SandboxesIDContextsCtxIDRestartPostParams, requestOptions ...RequestOption) (res *SuccessContextResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/restart"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDRestartPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDRestartPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDSignalPost invokes POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/signal operation.
//
// Send signal to context.
//
// POST /api/v1/sandboxes/{id}/contexts/{ctx_id}/signal
func (c *Client) APIV1SandboxesIDContextsCtxIDSignalPost(ctx context.Context, request *SignalContextRequest, params APIV1SandboxesIDContextsCtxIDSignalPostParams, options ...RequestOption) (*SuccessSignaledResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDSignalPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDSignalPost(ctx context.Context, request *SignalContextRequest, params APIV1SandboxesIDContextsCtxIDSignalPostParams, requestOptions ...RequestOption) (res *SuccessSignaledResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/signal"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDContextsCtxIDSignalPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDSignalPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDSignalPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDStatsGet invokes GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/stats operation.
//
// Get context stats.
//
// GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/stats
func (c *Client) APIV1SandboxesIDContextsCtxIDStatsGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDStatsGetParams, options ...RequestOption) (*SuccessContextStatsResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsCtxIDStatsGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDStatsGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDStatsGetParams, requestOptions ...RequestOption) (res *SuccessContextStatsResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/stats"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDStatsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDStatsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsCtxIDWsGet invokes GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/ws operation.
//
// Upgrades to WebSocket for streaming I/O.
// Client messages (JSON):
// - { "type": "input", "data": "ls\n", "request_id": "req-1" }
// - { "type": "resize", "rows": 24, "cols": 80 }
// - { "type": "signal", "signal": "INT" }
// Server messages (JSON):
// - { "type": "output", "source": "stdout", "data": "hello\n" }.
//
// GET /api/v1/sandboxes/{id}/contexts/{ctx_id}/ws
func (c *Client) APIV1SandboxesIDContextsCtxIDWsGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDWsGetParams, options ...RequestOption) error {
	_, err := c.sendAPIV1SandboxesIDContextsCtxIDWsGet(ctx, params, options...)
	return err
}

func (c *Client) sendAPIV1SandboxesIDContextsCtxIDWsGet(ctx context.Context, params APIV1SandboxesIDContextsCtxIDWsGetParams, requestOptions ...RequestOption) (res *APIV1SandboxesIDContextsCtxIDWsGetSwitchingProtocols, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts/"
	{
		// Encode "ctx_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "ctx_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CtxID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/ws"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsCtxIDWsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsCtxIDWsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsGet invokes GET /api/v1/sandboxes/{id}/contexts operation.
//
// List contexts.
//
// GET /api/v1/sandboxes/{id}/contexts
func (c *Client) APIV1SandboxesIDContextsGet(ctx context.Context, params APIV1SandboxesIDContextsGetParams, options ...RequestOption) (*SuccessContextListResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsGet(ctx context.Context, params APIV1SandboxesIDContextsGetParams, requestOptions ...RequestOption) (res *SuccessContextListResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDContextsPost invokes POST /api/v1/sandboxes/{id}/contexts operation.
//
// Create a context.
//
// POST /api/v1/sandboxes/{id}/contexts
func (c *Client) APIV1SandboxesIDContextsPost(ctx context.Context, request *CreateContextRequest, params APIV1SandboxesIDContextsPostParams, options ...RequestOption) (*SuccessContextResponse, error) {
	res, err := c.sendAPIV1SandboxesIDContextsPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDContextsPost(ctx context.Context, request *CreateContextRequest, params APIV1SandboxesIDContextsPostParams, requestOptions ...RequestOption) (res *SuccessContextResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/contexts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDContextsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDContextsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDContextsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDDelete invokes DELETE /api/v1/sandboxes/{id} operation.
//
// Delete (terminate) a sandbox.
//
// DELETE /api/v1/sandboxes/{id}
func (c *Client) APIV1SandboxesIDDelete(ctx context.Context, params APIV1SandboxesIDDeleteParams, options ...RequestOption) (APIV1SandboxesIDDeleteRes, error) {
	res, err := c.sendAPIV1SandboxesIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDDelete(ctx context.Context, params APIV1SandboxesIDDeleteParams, requestOptions ...RequestOption) (res APIV1SandboxesIDDeleteRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDFilesDelete invokes DELETE /api/v1/sandboxes/{id}/files operation.
//
// Delete file or directory.
//
// DELETE /api/v1/sandboxes/{id}/files
func (c *Client) APIV1SandboxesIDFilesDelete(ctx context.Context, params APIV1SandboxesIDFilesDeleteParams, options ...RequestOption) (*SuccessDeletedResponse, error) {
	res, err := c.sendAPIV1SandboxesIDFilesDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDFilesDelete(ctx context.Context, params APIV1SandboxesIDFilesDeleteParams, requestOptions ...RequestOption) (res *SuccessDeletedResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDFilesDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDFilesDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDFilesGet invokes GET /api/v1/sandboxes/{id}/files operation.
//
// Use query params:
// - path=/tmp/a.txt: target file path
// When `Accept` or `Content-Type` is `application/json`, returns a base64 JSON payload.
//
// GET /api/v1/sandboxes/{id}/files
func (c *Client) APIV1SandboxesIDFilesGet(ctx context.Context, params APIV1SandboxesIDFilesGetParams, options ...RequestOption) (APIV1SandboxesIDFilesGetRes, error) {
	res, err := c.sendAPIV1SandboxesIDFilesGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDFilesGet(ctx context.Context, params APIV1SandboxesIDFilesGetParams, requestOptions ...RequestOption) (res APIV1SandboxesIDFilesGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDFilesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDFilesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDFilesListGet invokes GET /api/v1/sandboxes/{id}/files/list operation.
//
// Use query params:
// - path=/tmp: target directory path.
//
// GET /api/v1/sandboxes/{id}/files/list
func (c *Client) APIV1SandboxesIDFilesListGet(ctx context.Context, params APIV1SandboxesIDFilesListGetParams, options ...RequestOption) (*SuccessFileListResponse, error) {
	res, err := c.sendAPIV1SandboxesIDFilesListGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDFilesListGet(ctx context.Context, params APIV1SandboxesIDFilesListGetParams, requestOptions ...RequestOption) (res *SuccessFileListResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/files/list"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDFilesListGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDFilesListGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDFilesMovePost invokes POST /api/v1/sandboxes/{id}/files/move operation.
//
// Move a file or directory.
//
// POST /api/v1/sandboxes/{id}/files/move
func (c *Client) APIV1SandboxesIDFilesMovePost(ctx context.Context, request *MoveFileRequest, params APIV1SandboxesIDFilesMovePostParams, options ...RequestOption) (*SuccessMovedResponse, error) {
	res, err := c.sendAPIV1SandboxesIDFilesMovePost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDFilesMovePost(ctx context.Context, request *MoveFileRequest, params APIV1SandboxesIDFilesMovePostParams, requestOptions ...RequestOption) (res *SuccessMovedResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/files/move"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDFilesMovePostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDFilesMovePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDFilesMovePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDFilesPost invokes POST /api/v1/sandboxes/{id}/files operation.
//
// Use `path` query param and `mkdir=true` to create directories, otherwise writes file content.
//
// POST /api/v1/sandboxes/{id}/files
func (c *Client) APIV1SandboxesIDFilesPost(ctx context.Context, request APIV1SandboxesIDFilesPostReq, params APIV1SandboxesIDFilesPostParams, options ...RequestOption) (APIV1SandboxesIDFilesPostRes, error) {
	res, err := c.sendAPIV1SandboxesIDFilesPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDFilesPost(ctx context.Context, request APIV1SandboxesIDFilesPostReq, params APIV1SandboxesIDFilesPostParams, requestOptions ...RequestOption) (res APIV1SandboxesIDFilesPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "mkdir" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "mkdir",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Mkdir.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "recursive" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "recursive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Recursive.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDFilesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDFilesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDFilesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDFilesStatGet invokes GET /api/v1/sandboxes/{id}/files/stat operation.
//
// Use query params:
// - path=/tmp/a.txt: target file path.
//
// GET /api/v1/sandboxes/{id}/files/stat
func (c *Client) APIV1SandboxesIDFilesStatGet(ctx context.Context, params APIV1SandboxesIDFilesStatGetParams, options ...RequestOption) (*SuccessFileStatResponse, error) {
	res, err := c.sendAPIV1SandboxesIDFilesStatGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDFilesStatGet(ctx context.Context, params APIV1SandboxesIDFilesStatGetParams, requestOptions ...RequestOption) (res *SuccessFileStatResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/files/stat"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Path))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDFilesStatGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDFilesStatGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDFilesWatchGet invokes GET /api/v1/sandboxes/{id}/files/watch operation.
//
// Upgrades to WebSocket for file watch events.
// Client messages:
// - { "action": "subscribe", "path": "/tmp", "recursive": false }
// - { "action": "unsubscribe", "watch_id": "watch-id" }
// Server messages:
// - { "type": "subscribed", "watch_id": "watch-id", "path": "/tmp" }
// - { "type": "event", "watch_id": "watch-id", "event": "write", "path": "/tmp/a.txt" }
// - { "type": "unsubscribed", "watch_id": "watch-id" }
// - { "type": "error", "error": "message" }.
//
// GET /api/v1/sandboxes/{id}/files/watch
func (c *Client) APIV1SandboxesIDFilesWatchGet(ctx context.Context, params APIV1SandboxesIDFilesWatchGetParams, options ...RequestOption) error {
	_, err := c.sendAPIV1SandboxesIDFilesWatchGet(ctx, params, options...)
	return err
}

func (c *Client) sendAPIV1SandboxesIDFilesWatchGet(ctx context.Context, params APIV1SandboxesIDFilesWatchGetParams, requestOptions ...RequestOption) (res *APIV1SandboxesIDFilesWatchGetSwitchingProtocols, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/files/watch"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDFilesWatchGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDFilesWatchGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDGet invokes GET /api/v1/sandboxes/{id} operation.
//
// Get sandbox by ID.
//
// GET /api/v1/sandboxes/{id}
func (c *Client) APIV1SandboxesIDGet(ctx context.Context, params APIV1SandboxesIDGetParams, options ...RequestOption) (APIV1SandboxesIDGetRes, error) {
	res, err := c.sendAPIV1SandboxesIDGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDGet(ctx context.Context, params APIV1SandboxesIDGetParams, requestOptions ...RequestOption) (res APIV1SandboxesIDGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDNetworkGet invokes GET /api/v1/sandboxes/{id}/network operation.
//
// Get sandbox network policy.
//
// GET /api/v1/sandboxes/{id}/network
func (c *Client) APIV1SandboxesIDNetworkGet(ctx context.Context, params APIV1SandboxesIDNetworkGetParams, options ...RequestOption) (APIV1SandboxesIDNetworkGetRes, error) {
	res, err := c.sendAPIV1SandboxesIDNetworkGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDNetworkGet(ctx context.Context, params APIV1SandboxesIDNetworkGetParams, requestOptions ...RequestOption) (res APIV1SandboxesIDNetworkGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/network"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDNetworkGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDNetworkGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDNetworkPatch invokes PATCH /api/v1/sandboxes/{id}/network operation.
//
// Update sandbox network policy.
//
// PATCH /api/v1/sandboxes/{id}/network
func (c *Client) APIV1SandboxesIDNetworkPatch(ctx context.Context, request *TplSandboxNetworkPolicy, params APIV1SandboxesIDNetworkPatchParams, options ...RequestOption) (*SuccessSandboxNetworkPolicyResponse, error) {
	res, err := c.sendAPIV1SandboxesIDNetworkPatch(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDNetworkPatch(ctx context.Context, request *TplSandboxNetworkPolicy, params APIV1SandboxesIDNetworkPatchParams, requestOptions ...RequestOption) (res *SuccessSandboxNetworkPolicyResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/network"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDNetworkPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDNetworkPatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDNetworkPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDPatch invokes PATCH /api/v1/sandboxes/{id} operation.
//
// Update sandbox configuration.
//
// PATCH /api/v1/sandboxes/{id}
func (c *Client) APIV1SandboxesIDPatch(ctx context.Context, request *SandboxUpdateRequest, params APIV1SandboxesIDPatchParams, options ...RequestOption) (APIV1SandboxesIDPatchRes, error) {
	res, err := c.sendAPIV1SandboxesIDPatch(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDPatch(ctx context.Context, request *SandboxUpdateRequest, params APIV1SandboxesIDPatchParams, requestOptions ...RequestOption) (res APIV1SandboxesIDPatchRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDPatchOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDPausePost invokes POST /api/v1/sandboxes/{id}/pause operation.
//
// Pause a sandbox.
//
// POST /api/v1/sandboxes/{id}/pause
func (c *Client) APIV1SandboxesIDPausePost(ctx context.Context, params APIV1SandboxesIDPausePostParams, options ...RequestOption) (APIV1SandboxesIDPausePostRes, error) {
	res, err := c.sendAPIV1SandboxesIDPausePost(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDPausePost(ctx context.Context, params APIV1SandboxesIDPausePostParams, requestOptions ...RequestOption) (res APIV1SandboxesIDPausePostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pause"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDPausePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDPausePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDRefreshPost invokes POST /api/v1/sandboxes/{id}/refresh operation.
//
// Refresh sandbox TTL.
//
// POST /api/v1/sandboxes/{id}/refresh
func (c *Client) APIV1SandboxesIDRefreshPost(ctx context.Context, request OptRefreshRequest, params APIV1SandboxesIDRefreshPostParams, options ...RequestOption) (APIV1SandboxesIDRefreshPostRes, error) {
	res, err := c.sendAPIV1SandboxesIDRefreshPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDRefreshPost(ctx context.Context, request OptRefreshRequest, params APIV1SandboxesIDRefreshPostParams, requestOptions ...RequestOption) (res APIV1SandboxesIDRefreshPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/refresh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDRefreshPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDRefreshPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDRefreshPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDResumePost invokes POST /api/v1/sandboxes/{id}/resume operation.
//
// Resume a sandbox.
//
// POST /api/v1/sandboxes/{id}/resume
func (c *Client) APIV1SandboxesIDResumePost(ctx context.Context, params APIV1SandboxesIDResumePostParams, options ...RequestOption) (APIV1SandboxesIDResumePostRes, error) {
	res, err := c.sendAPIV1SandboxesIDResumePost(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDResumePost(ctx context.Context, params APIV1SandboxesIDResumePostParams, requestOptions ...RequestOption) (res APIV1SandboxesIDResumePostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/resume"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDResumePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDResumePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDSandboxvolumesMountPost invokes POST /api/v1/sandboxes/{id}/sandboxvolumes/mount operation.
//
// Mount sandbox volume in sandbox.
//
// POST /api/v1/sandboxes/{id}/sandboxvolumes/mount
func (c *Client) APIV1SandboxesIDSandboxvolumesMountPost(ctx context.Context, request *MountRequest, params APIV1SandboxesIDSandboxvolumesMountPostParams, options ...RequestOption) (*SuccessMountResponse, error) {
	res, err := c.sendAPIV1SandboxesIDSandboxvolumesMountPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDSandboxvolumesMountPost(ctx context.Context, request *MountRequest, params APIV1SandboxesIDSandboxvolumesMountPostParams, requestOptions ...RequestOption) (res *SuccessMountResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sandboxvolumes/mount"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDSandboxvolumesMountPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDSandboxvolumesMountPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDSandboxvolumesMountPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDSandboxvolumesStatusGet invokes GET /api/v1/sandboxes/{id}/sandboxvolumes/status operation.
//
// Get sandbox volume mount status.
//
// GET /api/v1/sandboxes/{id}/sandboxvolumes/status
func (c *Client) APIV1SandboxesIDSandboxvolumesStatusGet(ctx context.Context, params APIV1SandboxesIDSandboxvolumesStatusGetParams, options ...RequestOption) (*SuccessMountStatusResponse, error) {
	res, err := c.sendAPIV1SandboxesIDSandboxvolumesStatusGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDSandboxvolumesStatusGet(ctx context.Context, params APIV1SandboxesIDSandboxvolumesStatusGetParams, requestOptions ...RequestOption) (res *SuccessMountStatusResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sandboxvolumes/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDSandboxvolumesStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDSandboxvolumesStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDSandboxvolumesUnmountPost invokes POST /api/v1/sandboxes/{id}/sandboxvolumes/unmount operation.
//
// Unmount sandbox volume.
//
// POST /api/v1/sandboxes/{id}/sandboxvolumes/unmount
func (c *Client) APIV1SandboxesIDSandboxvolumesUnmountPost(ctx context.Context, request *UnmountRequest, params APIV1SandboxesIDSandboxvolumesUnmountPostParams, options ...RequestOption) (*SuccessUnmountedResponse, error) {
	res, err := c.sendAPIV1SandboxesIDSandboxvolumesUnmountPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDSandboxvolumesUnmountPost(ctx context.Context, request *UnmountRequest, params APIV1SandboxesIDSandboxvolumesUnmountPostParams, requestOptions ...RequestOption) (res *SuccessUnmountedResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/sandboxvolumes/unmount"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesIDSandboxvolumesUnmountPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDSandboxvolumesUnmountPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDSandboxvolumesUnmountPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesIDStatusGet invokes GET /api/v1/sandboxes/{id}/status operation.
//
// Get sandbox status.
//
// GET /api/v1/sandboxes/{id}/status
func (c *Client) APIV1SandboxesIDStatusGet(ctx context.Context, params APIV1SandboxesIDStatusGetParams, options ...RequestOption) (APIV1SandboxesIDStatusGetRes, error) {
	res, err := c.sendAPIV1SandboxesIDStatusGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesIDStatusGet(ctx context.Context, params APIV1SandboxesIDStatusGetParams, requestOptions ...RequestOption) (res APIV1SandboxesIDStatusGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesIDStatusGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesIDStatusGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxesPost invokes POST /api/v1/sandboxes operation.
//
// Create (claim) a sandbox.
//
// POST /api/v1/sandboxes
func (c *Client) APIV1SandboxesPost(ctx context.Context, request *ClaimRequest, options ...RequestOption) (APIV1SandboxesPostRes, error) {
	res, err := c.sendAPIV1SandboxesPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxesPost(ctx context.Context, request *ClaimRequest, requestOptions ...RequestOption) (res APIV1SandboxesPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/v1/sandboxes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesGet invokes GET /api/v1/sandboxvolumes operation.
//
// List sandbox volumes.
//
// GET /api/v1/sandboxvolumes
func (c *Client) APIV1SandboxvolumesGet(ctx context.Context, options ...RequestOption) (*SuccessSandboxVolumeListResponse, error) {
	res, err := c.sendAPIV1SandboxvolumesGet(ctx, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesGet(ctx context.Context, requestOptions ...RequestOption) (res *SuccessSandboxVolumeListResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/v1/sandboxvolumes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesIDDelete invokes DELETE /api/v1/sandboxvolumes/{id} operation.
//
// Delete sandbox volume.
//
// DELETE /api/v1/sandboxvolumes/{id}
func (c *Client) APIV1SandboxvolumesIDDelete(ctx context.Context, params APIV1SandboxvolumesIDDeleteParams, options ...RequestOption) (APIV1SandboxvolumesIDDeleteRes, error) {
	res, err := c.sendAPIV1SandboxvolumesIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesIDDelete(ctx context.Context, params APIV1SandboxvolumesIDDeleteParams, requestOptions ...RequestOption) (res APIV1SandboxvolumesIDDeleteRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/sandboxvolumes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesIDGet invokes GET /api/v1/sandboxvolumes/{id} operation.
//
// Get sandbox volume.
//
// GET /api/v1/sandboxvolumes/{id}
func (c *Client) APIV1SandboxvolumesIDGet(ctx context.Context, params APIV1SandboxvolumesIDGetParams, options ...RequestOption) (APIV1SandboxvolumesIDGetRes, error) {
	res, err := c.sendAPIV1SandboxvolumesIDGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesIDGet(ctx context.Context, params APIV1SandboxvolumesIDGetParams, requestOptions ...RequestOption) (res APIV1SandboxvolumesIDGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/sandboxvolumes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesIDSnapshotsGet invokes GET /api/v1/sandboxvolumes/{id}/snapshots operation.
//
// List snapshots.
//
// GET /api/v1/sandboxvolumes/{id}/snapshots
func (c *Client) APIV1SandboxvolumesIDSnapshotsGet(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsGetParams, options ...RequestOption) (*SuccessSnapshotListResponse, error) {
	res, err := c.sendAPIV1SandboxvolumesIDSnapshotsGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesIDSnapshotsGet(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsGetParams, requestOptions ...RequestOption) (res *SuccessSnapshotListResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxvolumes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesIDSnapshotsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesIDSnapshotsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesIDSnapshotsPost invokes POST /api/v1/sandboxvolumes/{id}/snapshots operation.
//
// Create snapshot.
//
// POST /api/v1/sandboxvolumes/{id}/snapshots
func (c *Client) APIV1SandboxvolumesIDSnapshotsPost(ctx context.Context, request *CreateSnapshotRequest, params APIV1SandboxvolumesIDSnapshotsPostParams, options ...RequestOption) (*SuccessSnapshotResponse, error) {
	res, err := c.sendAPIV1SandboxvolumesIDSnapshotsPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesIDSnapshotsPost(ctx context.Context, request *CreateSnapshotRequest, params APIV1SandboxvolumesIDSnapshotsPostParams, requestOptions ...RequestOption) (res *SuccessSnapshotResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/v1/sandboxvolumes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxvolumesIDSnapshotsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesIDSnapshotsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesIDSnapshotsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesIDSnapshotsSnapshotIDDelete invokes DELETE /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id} operation.
//
// Delete snapshot.
//
// DELETE /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}
func (c *Client) APIV1SandboxvolumesIDSnapshotsSnapshotIDDelete(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDDeleteParams, options ...RequestOption) (*SuccessDeletedResponse, error) {
	res, err := c.sendAPIV1SandboxvolumesIDSnapshotsSnapshotIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesIDSnapshotsSnapshotIDDelete(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDDeleteParams, requestOptions ...RequestOption) (res *SuccessDeletedResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/api/v1/sandboxvolumes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots/"
	{
		// Encode "snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesIDSnapshotsSnapshotIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesIDSnapshotsSnapshotIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesIDSnapshotsSnapshotIDGet invokes GET /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id} operation.
//
// Get snapshot.
//
// GET /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}
func (c *Client) APIV1SandboxvolumesIDSnapshotsSnapshotIDGet(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDGetParams, options ...RequestOption) (APIV1SandboxvolumesIDSnapshotsSnapshotIDGetRes, error) {
	res, err := c.sendAPIV1SandboxvolumesIDSnapshotsSnapshotIDGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesIDSnapshotsSnapshotIDGet(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDGetParams, requestOptions ...RequestOption) (res APIV1SandboxvolumesIDSnapshotsSnapshotIDGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/api/v1/sandboxvolumes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots/"
	{
		// Encode "snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesIDSnapshotsSnapshotIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesIDSnapshotsSnapshotIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePost invokes POST /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}/restore operation.
//
// Restore snapshot.
//
// POST /api/v1/sandboxvolumes/{id}/snapshots/{snapshot_id}/restore
func (c *Client) APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePost(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePostParams, options ...RequestOption) (*SuccessRestoreResponse, error) {
	res, err := c.sendAPIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePost(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePost(ctx context.Context, params APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePostParams, requestOptions ...RequestOption) (res *SuccessRestoreResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [5]string
	pathParts[0] = "/api/v1/sandboxvolumes/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/snapshots/"
	{
		// Encode "snapshot_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "snapshot_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SnapshotID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/restore"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesIDSnapshotsSnapshotIDRestorePostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1SandboxvolumesPost invokes POST /api/v1/sandboxvolumes operation.
//
// Create sandbox volume.
//
// POST /api/v1/sandboxvolumes
func (c *Client) APIV1SandboxvolumesPost(ctx context.Context, request *CreateSandboxVolumeRequest, options ...RequestOption) (*SuccessSandboxVolumeResponse, error) {
	res, err := c.sendAPIV1SandboxvolumesPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAPIV1SandboxvolumesPost(ctx context.Context, request *CreateSandboxVolumeRequest, requestOptions ...RequestOption) (res *SuccessSandboxVolumeResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/v1/sandboxvolumes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1SandboxvolumesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1SandboxvolumesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1SandboxvolumesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1TemplatesGet invokes GET /api/v1/templates operation.
//
// List templates.
//
// GET /api/v1/templates
func (c *Client) APIV1TemplatesGet(ctx context.Context, options ...RequestOption) (*SuccessTemplateListResponse, error) {
	res, err := c.sendAPIV1TemplatesGet(ctx, options...)
	return res, err
}

func (c *Client) sendAPIV1TemplatesGet(ctx context.Context, requestOptions ...RequestOption) (res *SuccessTemplateListResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/v1/templates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1TemplatesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1TemplatesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1TemplatesIDDelete invokes DELETE /api/v1/templates/{id} operation.
//
// Delete template.
//
// DELETE /api/v1/templates/{id}
func (c *Client) APIV1TemplatesIDDelete(ctx context.Context, params APIV1TemplatesIDDeleteParams, options ...RequestOption) (*SuccessMessageResponse, error) {
	res, err := c.sendAPIV1TemplatesIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1TemplatesIDDelete(ctx context.Context, params APIV1TemplatesIDDeleteParams, requestOptions ...RequestOption) (res *SuccessMessageResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/templates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1TemplatesIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1TemplatesIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1TemplatesIDGet invokes GET /api/v1/templates/{id} operation.
//
// Get template.
//
// GET /api/v1/templates/{id}
func (c *Client) APIV1TemplatesIDGet(ctx context.Context, params APIV1TemplatesIDGetParams, options ...RequestOption) (APIV1TemplatesIDGetRes, error) {
	res, err := c.sendAPIV1TemplatesIDGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAPIV1TemplatesIDGet(ctx context.Context, params APIV1TemplatesIDGetParams, requestOptions ...RequestOption) (res APIV1TemplatesIDGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/templates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1TemplatesIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1TemplatesIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1TemplatesIDPut invokes PUT /api/v1/templates/{id} operation.
//
// Update template.
//
// PUT /api/v1/templates/{id}
func (c *Client) APIV1TemplatesIDPut(ctx context.Context, request *TemplateUpdateRequest, params APIV1TemplatesIDPutParams, options ...RequestOption) (*SuccessTemplateResponse, error) {
	res, err := c.sendAPIV1TemplatesIDPut(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendAPIV1TemplatesIDPut(ctx context.Context, request *TemplateUpdateRequest, params APIV1TemplatesIDPutParams, requestOptions ...RequestOption) (res *SuccessTemplateResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/v1/templates/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1TemplatesIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1TemplatesIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1TemplatesIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// APIV1TemplatesPost invokes POST /api/v1/templates operation.
//
// Create template.
//
// POST /api/v1/templates
func (c *Client) APIV1TemplatesPost(ctx context.Context, request *TemplateCreateRequest, options ...RequestOption) (*SuccessTemplateResponse, error) {
	res, err := c.sendAPIV1TemplatesPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAPIV1TemplatesPost(ctx context.Context, request *TemplateCreateRequest, requestOptions ...RequestOption) (res *SuccessTemplateResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/v1/templates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAPIV1TemplatesPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, APIV1TemplatesPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAPIV1TemplatesPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthChangePasswordPost invokes POST /auth/change-password operation.
//
// Change password.
//
// POST /auth/change-password
func (c *Client) AuthChangePasswordPost(ctx context.Context, request *ChangePasswordRequest, options ...RequestOption) (AuthChangePasswordPostRes, error) {
	res, err := c.sendAuthChangePasswordPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthChangePasswordPost(ctx context.Context, request *ChangePasswordRequest, requestOptions ...RequestOption) (res AuthChangePasswordPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/auth/change-password"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthChangePasswordPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, AuthChangePasswordPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthChangePasswordPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthLoginPost invokes POST /auth/login operation.
//
// Login with email and password.
//
// POST /auth/login
func (c *Client) AuthLoginPost(ctx context.Context, request *LoginRequest, options ...RequestOption) (AuthLoginPostRes, error) {
	res, err := c.sendAuthLoginPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthLoginPost(ctx context.Context, request *LoginRequest, requestOptions ...RequestOption) (res AuthLoginPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/auth/login"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthLoginPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthLoginPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthLogoutPost invokes POST /auth/logout operation.
//
// Logout.
//
// POST /auth/logout
func (c *Client) AuthLogoutPost(ctx context.Context, options ...RequestOption) (*SuccessMessageResponse, error) {
	res, err := c.sendAuthLogoutPost(ctx, options...)
	return res, err
}

func (c *Client) sendAuthLogoutPost(ctx context.Context, requestOptions ...RequestOption) (res *SuccessMessageResponse, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/auth/logout"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, AuthLogoutPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthLogoutPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthOidcProviderCallbackGet invokes GET /auth/oidc/{provider}/callback operation.
//
// OIDC callback.
//
// GET /auth/oidc/{provider}/callback
func (c *Client) AuthOidcProviderCallbackGet(ctx context.Context, params AuthOidcProviderCallbackGetParams, options ...RequestOption) (AuthOidcProviderCallbackGetRes, error) {
	res, err := c.sendAuthOidcProviderCallbackGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAuthOidcProviderCallbackGet(ctx context.Context, params AuthOidcProviderCallbackGetParams, requestOptions ...RequestOption) (res AuthOidcProviderCallbackGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/auth/oidc/"
	{
		// Encode "provider" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Provider))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/callback"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "code" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Code))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.State))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthOidcProviderCallbackGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthOidcProviderLoginGet invokes GET /auth/oidc/{provider}/login operation.
//
// Initiate OIDC login.
//
// GET /auth/oidc/{provider}/login
func (c *Client) AuthOidcProviderLoginGet(ctx context.Context, params AuthOidcProviderLoginGetParams, options ...RequestOption) (AuthOidcProviderLoginGetRes, error) {
	res, err := c.sendAuthOidcProviderLoginGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendAuthOidcProviderLoginGet(ctx context.Context, params AuthOidcProviderLoginGetParams, requestOptions ...RequestOption) (res AuthOidcProviderLoginGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/auth/oidc/"
	{
		// Encode "provider" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "provider",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Provider))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/login"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "return_url" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "return_url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ReturnURL.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthOidcProviderLoginGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthProvidersGet invokes GET /auth/providers operation.
//
// Get available auth providers.
//
// GET /auth/providers
func (c *Client) AuthProvidersGet(ctx context.Context, options ...RequestOption) (AuthProvidersGetRes, error) {
	res, err := c.sendAuthProvidersGet(ctx, options...)
	return res, err
}

func (c *Client) sendAuthProvidersGet(ctx context.Context, requestOptions ...RequestOption) (res AuthProvidersGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/auth/providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthProvidersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthRefreshPost invokes POST /auth/refresh operation.
//
// Refresh access token.
//
// POST /auth/refresh
func (c *Client) AuthRefreshPost(ctx context.Context, request *RefreshRequest, options ...RequestOption) (AuthRefreshPostRes, error) {
	res, err := c.sendAuthRefreshPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthRefreshPost(ctx context.Context, request *RefreshRequest, requestOptions ...RequestOption) (res AuthRefreshPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/auth/refresh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthRefreshPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthRefreshPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthRegisterPost invokes POST /auth/register operation.
//
// Register a new user.
//
// POST /auth/register
func (c *Client) AuthRegisterPost(ctx context.Context, request *RegisterRequest, options ...RequestOption) (AuthRegisterPostRes, error) {
	res, err := c.sendAuthRegisterPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthRegisterPost(ctx context.Context, request *RegisterRequest, requestOptions ...RequestOption) (res AuthRegisterPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/auth/register"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthRegisterPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthRegisterPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HealthzGet invokes GET /healthz operation.
//
// Health check.
//
// GET /healthz
func (c *Client) HealthzGet(ctx context.Context, options ...RequestOption) (HealthzGetRes, error) {
	res, err := c.sendHealthzGet(ctx, options...)
	return res, err
}

func (c *Client) sendHealthzGet(ctx context.Context, requestOptions ...RequestOption) (res HealthzGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/healthz"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHealthzGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// MetricsGet invokes GET /metrics operation.
//
// Prometheus metrics.
//
// GET /metrics
func (c *Client) MetricsGet(ctx context.Context, options ...RequestOption) (MetricsGetOK, error) {
	res, err := c.sendMetricsGet(ctx, options...)
	return res, err
}

func (c *Client) sendMetricsGet(ctx context.Context, requestOptions ...RequestOption) (res MetricsGetOK, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeMetricsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReadyzGet invokes GET /readyz operation.
//
// Readiness check.
//
// GET /readyz
func (c *Client) ReadyzGet(ctx context.Context, options ...RequestOption) (ReadyzGetRes, error) {
	res, err := c.sendReadyzGet(ctx, options...)
	return res, err
}

func (c *Client) sendReadyzGet(ctx context.Context, requestOptions ...RequestOption) (res ReadyzGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/readyz"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeReadyzGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsGet invokes GET /teams operation.
//
// List teams.
//
// GET /teams
func (c *Client) TeamsGet(ctx context.Context, options ...RequestOption) (TeamsGetRes, error) {
	res, err := c.sendTeamsGet(ctx, options...)
	return res, err
}

func (c *Client) sendTeamsGet(ctx context.Context, requestOptions ...RequestOption) (res TeamsGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsIDDelete invokes DELETE /teams/{id} operation.
//
// Delete a team.
//
// DELETE /teams/{id}
func (c *Client) TeamsIDDelete(ctx context.Context, params TeamsIDDeleteParams, options ...RequestOption) (TeamsIDDeleteRes, error) {
	res, err := c.sendTeamsIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendTeamsIDDelete(ctx context.Context, params TeamsIDDeleteParams, requestOptions ...RequestOption) (res TeamsIDDeleteRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/teams/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsIDGet invokes GET /teams/{id} operation.
//
// Get a team.
//
// GET /teams/{id}
func (c *Client) TeamsIDGet(ctx context.Context, params TeamsIDGetParams, options ...RequestOption) (TeamsIDGetRes, error) {
	res, err := c.sendTeamsIDGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendTeamsIDGet(ctx context.Context, params TeamsIDGetParams, requestOptions ...RequestOption) (res TeamsIDGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/teams/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsIDGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsIDMembersGet invokes GET /teams/{id}/members operation.
//
// List team members.
//
// GET /teams/{id}/members
func (c *Client) TeamsIDMembersGet(ctx context.Context, params TeamsIDMembersGetParams, options ...RequestOption) (TeamsIDMembersGetRes, error) {
	res, err := c.sendTeamsIDMembersGet(ctx, params, options...)
	return res, err
}

func (c *Client) sendTeamsIDMembersGet(ctx context.Context, params TeamsIDMembersGetParams, requestOptions ...RequestOption) (res TeamsIDMembersGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsIDMembersGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsIDMembersGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsIDMembersPost invokes POST /teams/{id}/members operation.
//
// Add team member.
//
// POST /teams/{id}/members
func (c *Client) TeamsIDMembersPost(ctx context.Context, request *AddTeamMemberRequest, params TeamsIDMembersPostParams, options ...RequestOption) (TeamsIDMembersPostRes, error) {
	res, err := c.sendTeamsIDMembersPost(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendTeamsIDMembersPost(ctx context.Context, request *AddTeamMemberRequest, params TeamsIDMembersPostParams, requestOptions ...RequestOption) (res TeamsIDMembersPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/teams/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsIDMembersPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsIDMembersPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsIDMembersPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsIDMembersUserIdDelete invokes DELETE /teams/{id}/members/{userId} operation.
//
// Remove team member.
//
// DELETE /teams/{id}/members/{userId}
func (c *Client) TeamsIDMembersUserIdDelete(ctx context.Context, params TeamsIDMembersUserIdDeleteParams, options ...RequestOption) (TeamsIDMembersUserIdDeleteRes, error) {
	res, err := c.sendTeamsIDMembersUserIdDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendTeamsIDMembersUserIdDelete(ctx context.Context, params TeamsIDMembersUserIdDeleteParams, requestOptions ...RequestOption) (res TeamsIDMembersUserIdDeleteRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsIDMembersUserIdDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsIDMembersUserIdDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsIDMembersUserIdPut invokes PUT /teams/{id}/members/{userId} operation.
//
// Update team member role.
//
// PUT /teams/{id}/members/{userId}
func (c *Client) TeamsIDMembersUserIdPut(ctx context.Context, request *UpdateTeamMemberRequest, params TeamsIDMembersUserIdPutParams, options ...RequestOption) (TeamsIDMembersUserIdPutRes, error) {
	res, err := c.sendTeamsIDMembersUserIdPut(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendTeamsIDMembersUserIdPut(ctx context.Context, request *UpdateTeamMemberRequest, params TeamsIDMembersUserIdPutParams, requestOptions ...RequestOption) (res TeamsIDMembersUserIdPutRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/teams/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsIDMembersUserIdPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsIDMembersUserIdPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsIDMembersUserIdPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsIDPut invokes PUT /teams/{id} operation.
//
// Update a team.
//
// PUT /teams/{id}
func (c *Client) TeamsIDPut(ctx context.Context, request *UpdateTeamRequest, params TeamsIDPutParams, options ...RequestOption) (TeamsIDPutRes, error) {
	res, err := c.sendTeamsIDPut(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendTeamsIDPut(ctx context.Context, request *UpdateTeamRequest, params TeamsIDPutParams, requestOptions ...RequestOption) (res TeamsIDPutRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/teams/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsIDPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsIDPutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsIDPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TeamsPost invokes POST /teams operation.
//
// Create a team.
//
// POST /teams
func (c *Client) TeamsPost(ctx context.Context, request *CreateTeamRequest, options ...RequestOption) (TeamsPostRes, error) {
	res, err := c.sendTeamsPost(ctx, request, options...)
	return res, err
}

func (c *Client) sendTeamsPost(ctx context.Context, request *CreateTeamRequest, requestOptions ...RequestOption) (res TeamsPostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTeamsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, TeamsPostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeTeamsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersMeGet invokes GET /users/me operation.
//
// Get current user.
//
// GET /users/me
func (c *Client) UsersMeGet(ctx context.Context, options ...RequestOption) (UsersMeGetRes, error) {
	res, err := c.sendUsersMeGet(ctx, options...)
	return res, err
}

func (c *Client) sendUsersMeGet(ctx context.Context, requestOptions ...RequestOption) (res UsersMeGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/users/me"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UsersMeGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersMeGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersMeIdentitiesGet invokes GET /users/me/identities operation.
//
// List current user identities.
//
// GET /users/me/identities
func (c *Client) UsersMeIdentitiesGet(ctx context.Context, options ...RequestOption) (UsersMeIdentitiesGetRes, error) {
	res, err := c.sendUsersMeIdentitiesGet(ctx, options...)
	return res, err
}

func (c *Client) sendUsersMeIdentitiesGet(ctx context.Context, requestOptions ...RequestOption) (res UsersMeIdentitiesGetRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/users/me/identities"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UsersMeIdentitiesGetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersMeIdentitiesGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersMeIdentitiesIDDelete invokes DELETE /users/me/identities/{id} operation.
//
// Delete a user identity.
//
// DELETE /users/me/identities/{id}
func (c *Client) UsersMeIdentitiesIDDelete(ctx context.Context, params UsersMeIdentitiesIDDeleteParams, options ...RequestOption) (UsersMeIdentitiesIDDeleteRes, error) {
	res, err := c.sendUsersMeIdentitiesIDDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersMeIdentitiesIDDelete(ctx context.Context, params UsersMeIdentitiesIDDeleteParams, requestOptions ...RequestOption) (res UsersMeIdentitiesIDDeleteRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/users/me/identities/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UsersMeIdentitiesIDDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersMeIdentitiesIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersMePut invokes PUT /users/me operation.
//
// Update current user.
//
// PUT /users/me
func (c *Client) UsersMePut(ctx context.Context, request *UpdateUserRequest, options ...RequestOption) (UsersMePutRes, error) {
	res, err := c.sendUsersMePut(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersMePut(ctx context.Context, request *UpdateUserRequest, requestOptions ...RequestOption) (res UsersMePutRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/users/me"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersMePutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, UsersMePutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersMePutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
