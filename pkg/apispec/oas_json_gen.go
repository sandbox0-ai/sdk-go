// Code generated by ogen, DO NOT EDIT.

package apispec

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *APIKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIKey) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.KeyValue.Set {
			e.FieldStart("key_value")
			s.KeyValue.Encode(e)
		}
	}
	{
		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		e.FieldStart("created_by")
		e.Str(s.CreatedBy)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("roles")
		e.ArrStart()
		for _, elem := range s.Roles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("is_active")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("expires_at")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		if s.LastUsedAt.Set {
			e.FieldStart("last_used_at")
			s.LastUsedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UsageCount.Set {
			e.FieldStart("usage_count")
			s.UsageCount.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfAPIKey = [14]string{
	0:  "id",
	1:  "key_value",
	2:  "team_id",
	3:  "user_id",
	4:  "created_by",
	5:  "name",
	6:  "type",
	7:  "roles",
	8:  "is_active",
	9:  "expires_at",
	10: "last_used_at",
	11: "usage_count",
	12: "created_at",
	13: "updated_at",
}

// Decode decodes APIKey from json.
func (s *APIKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKey to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key_value":
			if err := func() error {
				s.KeyValue.Reset()
				if err := s.KeyValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key_value\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "created_by":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.CreatedBy = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_by\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "roles":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.Roles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Roles = append(s.Roles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roles\"")
			}
		case "is_active":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_active\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "last_used_at":
			if err := func() error {
				s.LastUsedAt.Reset()
				if err := s.LastUsedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_used_at\"")
			}
		case "usage_count":
			if err := func() error {
				s.UsageCount.Reset()
				if err := s.UsageCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage_count\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIKey")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11110101,
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIKey) {
					name = jsonFieldsNameOfAPIKey[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIKeysIDDeactivatePostForbidden as json.
func (s *APIKeysIDDeactivatePostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIKeysIDDeactivatePostForbidden from json.
func (s *APIKeysIDDeactivatePostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeysIDDeactivatePostForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIKeysIDDeactivatePostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeysIDDeactivatePostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeysIDDeactivatePostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIKeysIDDeactivatePostNotFound as json.
func (s *APIKeysIDDeactivatePostNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIKeysIDDeactivatePostNotFound from json.
func (s *APIKeysIDDeactivatePostNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeysIDDeactivatePostNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIKeysIDDeactivatePostNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeysIDDeactivatePostNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeysIDDeactivatePostNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIKeysIDDeleteForbidden as json.
func (s *APIKeysIDDeleteForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIKeysIDDeleteForbidden from json.
func (s *APIKeysIDDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeysIDDeleteForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIKeysIDDeleteForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeysIDDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeysIDDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIKeysIDDeleteNotFound as json.
func (s *APIKeysIDDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIKeysIDDeleteNotFound from json.
func (s *APIKeysIDDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIKeysIDDeleteNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIKeysIDDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIKeysIDDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIKeysIDDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1RegistryCredentialsPostInternalServerError as json.
func (s *APIV1RegistryCredentialsPostInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1RegistryCredentialsPostInternalServerError from json.
func (s *APIV1RegistryCredentialsPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1RegistryCredentialsPostInternalServerError to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1RegistryCredentialsPostInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1RegistryCredentialsPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1RegistryCredentialsPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1RegistryCredentialsPostUnauthorized as json.
func (s *APIV1RegistryCredentialsPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1RegistryCredentialsPostUnauthorized from json.
func (s *APIV1RegistryCredentialsPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1RegistryCredentialsPostUnauthorized to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1RegistryCredentialsPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1RegistryCredentialsPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1RegistryCredentialsPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1SandboxesIDDeleteForbidden as json.
func (s *APIV1SandboxesIDDeleteForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1SandboxesIDDeleteForbidden from json.
func (s *APIV1SandboxesIDDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDDeleteForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1SandboxesIDDeleteForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1SandboxesIDDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1SandboxesIDDeleteNotFound as json.
func (s *APIV1SandboxesIDDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1SandboxesIDDeleteNotFound from json.
func (s *APIV1SandboxesIDDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDDeleteNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1SandboxesIDDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1SandboxesIDDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1SandboxesIDFilesGetOKApplicationJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1SandboxesIDFilesGetOKApplicationJSON) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1SandboxesIDFilesGetOKApplicationJSON = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes APIV1SandboxesIDFilesGetOKApplicationJSON from json.
func (s *APIV1SandboxesIDFilesGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDFilesGetOKApplicationJSON to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1SandboxesIDFilesGetOKApplicationJSON")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1SandboxesIDFilesGetOKApplicationJSON) {
					name = jsonFieldsNameOfAPIV1SandboxesIDFilesGetOKApplicationJSON[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1SandboxesIDFilesGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDFilesGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1SandboxesIDFilesGetOKApplicationJSONSuccess as json.
func (s APIV1SandboxesIDFilesGetOKApplicationJSONSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes APIV1SandboxesIDFilesGetOKApplicationJSONSuccess from json.
func (s *APIV1SandboxesIDFilesGetOKApplicationJSONSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDFilesGetOKApplicationJSONSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = APIV1SandboxesIDFilesGetOKApplicationJSONSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1SandboxesIDFilesGetOKApplicationJSONSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDFilesGetOKApplicationJSONSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1SandboxesIDGetForbidden as json.
func (s *APIV1SandboxesIDGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1SandboxesIDGetForbidden from json.
func (s *APIV1SandboxesIDGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDGetForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1SandboxesIDGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1SandboxesIDGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1SandboxesIDGetNotFound as json.
func (s *APIV1SandboxesIDGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1SandboxesIDGetNotFound from json.
func (s *APIV1SandboxesIDGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDGetNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1SandboxesIDGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1SandboxesIDGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1SandboxesIDPutBadRequest as json.
func (s *APIV1SandboxesIDPutBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1SandboxesIDPutBadRequest from json.
func (s *APIV1SandboxesIDPutBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDPutBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1SandboxesIDPutBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1SandboxesIDPutBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDPutBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1SandboxesIDPutNotFound as json.
func (s *APIV1SandboxesIDPutNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes APIV1SandboxesIDPutNotFound from json.
func (s *APIV1SandboxesIDPutNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1SandboxesIDPutNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = APIV1SandboxesIDPutNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1SandboxesIDPutNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1SandboxesIDPutNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddTeamMemberRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddTeamMemberRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
}

var jsonFieldsNameOfAddTeamMemberRequest = [2]string{
	0: "email",
	1: "role",
}

// Decode decodes AddTeamMemberRequest from json.
func (s *AddTeamMemberRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddTeamMemberRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddTeamMemberRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddTeamMemberRequest) {
					name = jsonFieldsNameOfAddTeamMemberRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddTeamMemberRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddTeamMemberRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddTeamMemberRequestRole as json.
func (s AddTeamMemberRequestRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddTeamMemberRequestRole from json.
func (s *AddTeamMemberRequestRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddTeamMemberRequestRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddTeamMemberRequestRole(v) {
	case AddTeamMemberRequestRoleAdmin:
		*s = AddTeamMemberRequestRoleAdmin
	case AddTeamMemberRequestRoleDeveloper:
		*s = AddTeamMemberRequestRoleDeveloper
	case AddTeamMemberRequestRoleViewer:
		*s = AddTeamMemberRequestRoleViewer
	default:
		*s = AddTeamMemberRequestRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddTeamMemberRequestRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddTeamMemberRequestRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Affinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Affinity) encodeFields(e *jx.Encoder) {
	{
		if s.NodeAffinity.Set {
			e.FieldStart("nodeAffinity")
			s.NodeAffinity.Encode(e)
		}
	}
	{
		if s.PodAffinity.Set {
			e.FieldStart("podAffinity")
			s.PodAffinity.Encode(e)
		}
	}
}

var jsonFieldsNameOfAffinity = [2]string{
	0: "nodeAffinity",
	1: "podAffinity",
}

// Decode decodes Affinity from json.
func (s *Affinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Affinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeAffinity":
			if err := func() error {
				s.NodeAffinity.Reset()
				if err := s.NodeAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeAffinity\"")
			}
		case "podAffinity":
			if err := func() error {
				s.PodAffinity.Reset()
				if err := s.PodAffinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinity\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Affinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Affinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Affinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthChangePasswordPostBadRequest as json.
func (s *AuthChangePasswordPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthChangePasswordPostBadRequest from json.
func (s *AuthChangePasswordPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthChangePasswordPostBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthChangePasswordPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthChangePasswordPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthChangePasswordPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthChangePasswordPostUnauthorized as json.
func (s *AuthChangePasswordPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthChangePasswordPostUnauthorized from json.
func (s *AuthChangePasswordPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthChangePasswordPostUnauthorized to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthChangePasswordPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthChangePasswordPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthChangePasswordPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthLoginPostBadRequest as json.
func (s *AuthLoginPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthLoginPostBadRequest from json.
func (s *AuthLoginPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthLoginPostBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthLoginPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthLoginPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthLoginPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthLoginPostForbidden as json.
func (s *AuthLoginPostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthLoginPostForbidden from json.
func (s *AuthLoginPostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthLoginPostForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthLoginPostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthLoginPostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthLoginPostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthLoginPostUnauthorized as json.
func (s *AuthLoginPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthLoginPostUnauthorized from json.
func (s *AuthLoginPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthLoginPostUnauthorized to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthLoginPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthLoginPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthLoginPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthOidcProviderCallbackGetBadRequest as json.
func (s *AuthOidcProviderCallbackGetBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthOidcProviderCallbackGetBadRequest from json.
func (s *AuthOidcProviderCallbackGetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthOidcProviderCallbackGetBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthOidcProviderCallbackGetBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthOidcProviderCallbackGetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthOidcProviderCallbackGetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthOidcProviderCallbackGetUnauthorized as json.
func (s *AuthOidcProviderCallbackGetUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthOidcProviderCallbackGetUnauthorized from json.
func (s *AuthOidcProviderCallbackGetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthOidcProviderCallbackGetUnauthorized to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthOidcProviderCallbackGetUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthOidcProviderCallbackGetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthOidcProviderCallbackGetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthOidcProviderLoginGetBadRequest as json.
func (s *AuthOidcProviderLoginGetBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthOidcProviderLoginGetBadRequest from json.
func (s *AuthOidcProviderLoginGetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthOidcProviderLoginGetBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthOidcProviderLoginGetBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthOidcProviderLoginGetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthOidcProviderLoginGetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthOidcProviderLoginGetNotFound as json.
func (s *AuthOidcProviderLoginGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthOidcProviderLoginGetNotFound from json.
func (s *AuthOidcProviderLoginGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthOidcProviderLoginGetNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthOidcProviderLoginGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthOidcProviderLoginGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthOidcProviderLoginGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
}

var jsonFieldsNameOfAuthProvider = [3]string{
	0: "id",
	1: "name",
	2: "type",
}

// Decode decodes AuthProvider from json.
func (s *AuthProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthProvider) {
					name = jsonFieldsNameOfAuthProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthRefreshPostBadRequest as json.
func (s *AuthRefreshPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthRefreshPostBadRequest from json.
func (s *AuthRefreshPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthRefreshPostBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthRefreshPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthRefreshPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthRefreshPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthRefreshPostUnauthorized as json.
func (s *AuthRefreshPostUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthRefreshPostUnauthorized from json.
func (s *AuthRefreshPostUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthRefreshPostUnauthorized to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthRefreshPostUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthRefreshPostUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthRefreshPostUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthRegisterPostBadRequest as json.
func (s *AuthRegisterPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthRegisterPostBadRequest from json.
func (s *AuthRegisterPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthRegisterPostBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthRegisterPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthRegisterPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthRegisterPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthRegisterPostConflict as json.
func (s *AuthRegisterPostConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthRegisterPostConflict from json.
func (s *AuthRegisterPostConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthRegisterPostConflict to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthRegisterPostConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthRegisterPostConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthRegisterPostConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthRegisterPostForbidden as json.
func (s *AuthRegisterPostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes AuthRegisterPostForbidden from json.
func (s *AuthRegisterPostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthRegisterPostForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthRegisterPostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthRegisterPostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthRegisterPostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Capabilities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Capabilities) encodeFields(e *jx.Encoder) {
	{
		if s.Drop != nil {
			e.FieldStart("drop")
			e.ArrStart()
			for _, elem := range s.Drop {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCapabilities = [1]string{
	0: "drop",
}

// Decode decodes Capabilities from json.
func (s *Capabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Capabilities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "drop":
			if err := func() error {
				s.Drop = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Drop = append(s.Drop, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"drop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Capabilities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Capabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Capabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChangePasswordRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChangePasswordRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("old_password")
		e.Str(s.OldPassword)
	}
	{
		e.FieldStart("new_password")
		e.Str(s.NewPassword)
	}
}

var jsonFieldsNameOfChangePasswordRequest = [2]string{
	0: "old_password",
	1: "new_password",
}

// Decode decodes ChangePasswordRequest from json.
func (s *ChangePasswordRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChangePasswordRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "old_password":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.OldPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_password\"")
			}
		case "new_password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NewPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChangePasswordRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfChangePasswordRequest) {
					name = jsonFieldsNameOfChangePasswordRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChangePasswordRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChangePasswordRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimRequest = [2]string{
	0: "template",
	1: "config",
}

// Decode decodes ClaimRequest from json.
func (s *ClaimRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClaimResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClaimResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandbox_id")
		e.Str(s.SandboxID)
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("pod_name")
		e.Str(s.PodName)
	}
	{
		e.FieldStart("template")
		e.Str(s.Template)
	}
	{
		if s.ClusterID.Set {
			e.FieldStart("cluster_id")
			s.ClusterID.Encode(e)
		}
	}
}

var jsonFieldsNameOfClaimResponse = [5]string{
	0: "sandbox_id",
	1: "status",
	2: "pod_name",
	3: "template",
	4: "cluster_id",
}

// Decode decodes ClaimResponse from json.
func (s *ClaimResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClaimResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandbox_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandbox_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "pod_name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.PodName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pod_name\"")
			}
		case "template":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Template = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "cluster_id":
			if err := func() error {
				s.ClusterID.Reset()
				if err := s.ClusterID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cluster_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClaimResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfClaimResponse) {
					name = jsonFieldsNameOfClaimResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClaimResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClaimResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContainerSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContainerSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("image")
		e.Str(s.Image)
	}
	{
		if s.ImagePullPolicy.Set {
			e.FieldStart("imagePullPolicy")
			s.ImagePullPolicy.Encode(e)
		}
	}
	{
		if s.Env != nil {
			e.FieldStart("env")
			e.ArrStart()
			for _, elem := range s.Env {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("resources")
		s.Resources.Encode(e)
	}
	{
		if s.SecurityContext.Set {
			e.FieldStart("securityContext")
			s.SecurityContext.Encode(e)
		}
	}
}

var jsonFieldsNameOfContainerSpec = [5]string{
	0: "image",
	1: "imagePullPolicy",
	2: "env",
	3: "resources",
	4: "securityContext",
}

// Decode decodes ContainerSpec from json.
func (s *ContainerSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContainerSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "image":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Image = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "imagePullPolicy":
			if err := func() error {
				s.ImagePullPolicy.Reset()
				if err := s.ImagePullPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imagePullPolicy\"")
			}
		case "env":
			if err := func() error {
				s.Env = make([]EnvVar, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnvVar
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Env = append(s.Env, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env\"")
			}
		case "resources":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Resources.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		case "securityContext":
			if err := func() error {
				s.SecurityContext.Reset()
				if err := s.SecurityContext.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityContext\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContainerSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContainerSpec) {
					name = jsonFieldsNameOfContainerSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContainerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContainerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContextExecResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContextExecResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("output")
		e.Str(s.Output)
	}
}

var jsonFieldsNameOfContextExecResponse = [1]string{
	0: "output",
}

// Decode decodes ContextExecResponse from json.
func (s *ContextExecResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextExecResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "output":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Output = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextExecResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContextExecResponse) {
					name = jsonFieldsNameOfContextExecResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContextExecResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextExecResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContextInputRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContextInputRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("data")
		e.Str(s.Data)
	}
}

var jsonFieldsNameOfContextInputRequest = [1]string{
	0: "data",
}

// Decode decodes ContextInputRequest from json.
func (s *ContextInputRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextInputRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "data":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Data = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextInputRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContextInputRequest) {
					name = jsonFieldsNameOfContextInputRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContextInputRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextInputRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContextResourceUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContextResourceUsage) encodeFields(e *jx.Encoder) {
	{
		if s.ContextID.Set {
			e.FieldStart("context_id")
			s.ContextID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Running.Set {
			e.FieldStart("running")
			s.Running.Encode(e)
		}
	}
	{
		if s.Paused.Set {
			e.FieldStart("paused")
			s.Paused.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
}

var jsonFieldsNameOfContextResourceUsage = [6]string{
	0: "context_id",
	1: "type",
	2: "language",
	3: "running",
	4: "paused",
	5: "usage",
}

// Decode decodes ContextResourceUsage from json.
func (s *ContextResourceUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextResourceUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context_id":
			if err := func() error {
				s.ContextID.Reset()
				if err := s.ContextID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context_id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "running":
			if err := func() error {
				s.Running.Reset()
				if err := s.Running.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"running\"")
			}
		case "paused":
			if err := func() error {
				s.Paused.Reset()
				if err := s.Paused.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextResourceUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContextResourceUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextResourceUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContextResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContextResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Cwd.Set {
			e.FieldStart("cwd")
			s.Cwd.Encode(e)
		}
	}
	{
		if s.EnvVars.Set {
			e.FieldStart("env_vars")
			s.EnvVars.Encode(e)
		}
	}
	{
		e.FieldStart("running")
		e.Bool(s.Running)
	}
	{
		e.FieldStart("paused")
		e.Bool(s.Paused)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		if s.Output.Set {
			e.FieldStart("output")
			s.Output.Encode(e)
		}
	}
}

var jsonFieldsNameOfContextResponse = [9]string{
	0: "id",
	1: "type",
	2: "language",
	3: "cwd",
	4: "env_vars",
	5: "running",
	6: "paused",
	7: "created_at",
	8: "output",
}

// Decode decodes ContextResponse from json.
func (s *ContextResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextResponse to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "cwd":
			if err := func() error {
				s.Cwd.Reset()
				if err := s.Cwd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cwd\"")
			}
		case "env_vars":
			if err := func() error {
				s.EnvVars.Reset()
				if err := s.EnvVars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env_vars\"")
			}
		case "running":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Running = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"running\"")
			}
		case "paused":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Paused = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "output":
			if err := func() error {
				s.Output.Reset()
				if err := s.Output.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"output\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11100011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfContextResponse) {
					name = jsonFieldsNameOfContextResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContextResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ContextResponseEnvVars) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ContextResponseEnvVars) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes ContextResponseEnvVars from json.
func (s *ContextResponseEnvVars) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextResponseEnvVars to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextResponseEnvVars")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContextResponseEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextResponseEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContextStatsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContextStatsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ContextID.Set {
			e.FieldStart("context_id")
			s.ContextID.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Running.Set {
			e.FieldStart("running")
			s.Running.Encode(e)
		}
	}
	{
		if s.Paused.Set {
			e.FieldStart("paused")
			s.Paused.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
}

var jsonFieldsNameOfContextStatsResponse = [6]string{
	0: "context_id",
	1: "type",
	2: "language",
	3: "running",
	4: "paused",
	5: "usage",
}

// Decode decodes ContextStatsResponse from json.
func (s *ContextStatsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContextStatsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context_id":
			if err := func() error {
				s.ContextID.Reset()
				if err := s.ContextID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context_id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "running":
			if err := func() error {
				s.Running.Reset()
				if err := s.Running.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"running\"")
			}
		case "paused":
			if err := func() error {
				s.Paused.Reset()
				if err := s.Paused.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContextStatsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContextStatsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContextStatsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAPIKeyRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAPIKeyRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Roles != nil {
			e.FieldStart("roles")
			e.ArrStart()
			for _, elem := range s.Roles {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExpiresIn.Set {
			e.FieldStart("expires_in")
			s.ExpiresIn.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateAPIKeyRequest = [4]string{
	0: "name",
	1: "type",
	2: "roles",
	3: "expires_in",
}

// Decode decodes CreateAPIKeyRequest from json.
func (s *CreateAPIKeyRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAPIKeyRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "roles":
			if err := func() error {
				s.Roles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Roles = append(s.Roles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roles\"")
			}
		case "expires_in":
			if err := func() error {
				s.ExpiresIn.Reset()
				if err := s.ExpiresIn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_in\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAPIKeyRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAPIKeyRequest) {
					name = jsonFieldsNameOfCreateAPIKeyRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAPIKeyRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAPIKeyRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAPIKeyRequestType as json.
func (s CreateAPIKeyRequestType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateAPIKeyRequestType from json.
func (s *CreateAPIKeyRequestType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAPIKeyRequestType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateAPIKeyRequestType(v) {
	case CreateAPIKeyRequestTypeUser:
		*s = CreateAPIKeyRequestTypeUser
	case CreateAPIKeyRequestTypeService:
		*s = CreateAPIKeyRequestTypeService
	default:
		*s = CreateAPIKeyRequestType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateAPIKeyRequestType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAPIKeyRequestType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAPIKeyResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAPIKeyResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("roles")
		e.ArrStart()
		for _, elem := range s.Roles {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		e.FieldStart("expires_at")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfCreateAPIKeyResponse = [8]string{
	0: "id",
	1: "name",
	2: "type",
	3: "roles",
	4: "team_id",
	5: "key",
	6: "expires_at",
	7: "created_at",
}

// Decode decodes CreateAPIKeyResponse from json.
func (s *CreateAPIKeyResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAPIKeyResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "roles":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Roles = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Roles = append(s.Roles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"roles\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAPIKeyResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAPIKeyResponse) {
					name = jsonFieldsNameOfCreateAPIKeyResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAPIKeyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAPIKeyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCMDContextRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCMDContextRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("command")
		e.ArrStart()
		for _, elem := range s.Command {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateCMDContextRequest = [1]string{
	0: "command",
}

// Decode decodes CreateCMDContextRequest from json.
func (s *CreateCMDContextRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCMDContextRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCMDContextRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCMDContextRequest) {
					name = jsonFieldsNameOfCreateCMDContextRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCMDContextRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCMDContextRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateContextRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateContextRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Repl.Set {
			e.FieldStart("repl")
			s.Repl.Encode(e)
		}
	}
	{
		if s.Cmd.Set {
			e.FieldStart("cmd")
			s.Cmd.Encode(e)
		}
	}
	{
		if s.WaitUntilDone.Set {
			e.FieldStart("wait_until_done")
			s.WaitUntilDone.Encode(e)
		}
	}
	{
		if s.Cwd.Set {
			e.FieldStart("cwd")
			s.Cwd.Encode(e)
		}
	}
	{
		if s.EnvVars.Set {
			e.FieldStart("env_vars")
			s.EnvVars.Encode(e)
		}
	}
	{
		if s.PtySize.Set {
			e.FieldStart("pty_size")
			s.PtySize.Encode(e)
		}
	}
	{
		if s.IdleTimeoutSec.Set {
			e.FieldStart("idle_timeout_sec")
			s.IdleTimeoutSec.Encode(e)
		}
	}
	{
		if s.TTLSec.Set {
			e.FieldStart("ttl_sec")
			s.TTLSec.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateContextRequest = [9]string{
	0: "type",
	1: "repl",
	2: "cmd",
	3: "wait_until_done",
	4: "cwd",
	5: "env_vars",
	6: "pty_size",
	7: "idle_timeout_sec",
	8: "ttl_sec",
}

// Decode decodes CreateContextRequest from json.
func (s *CreateContextRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateContextRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "repl":
			if err := func() error {
				s.Repl.Reset()
				if err := s.Repl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repl\"")
			}
		case "cmd":
			if err := func() error {
				s.Cmd.Reset()
				if err := s.Cmd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cmd\"")
			}
		case "wait_until_done":
			if err := func() error {
				s.WaitUntilDone.Reset()
				if err := s.WaitUntilDone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wait_until_done\"")
			}
		case "cwd":
			if err := func() error {
				s.Cwd.Reset()
				if err := s.Cwd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cwd\"")
			}
		case "env_vars":
			if err := func() error {
				s.EnvVars.Reset()
				if err := s.EnvVars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env_vars\"")
			}
		case "pty_size":
			if err := func() error {
				s.PtySize.Reset()
				if err := s.PtySize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pty_size\"")
			}
		case "idle_timeout_sec":
			if err := func() error {
				s.IdleTimeoutSec.Reset()
				if err := s.IdleTimeoutSec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idle_timeout_sec\"")
			}
		case "ttl_sec":
			if err := func() error {
				s.TTLSec.Reset()
				if err := s.TTLSec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl_sec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateContextRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateContextRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateContextRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s CreateContextRequestEnvVars) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s CreateContextRequestEnvVars) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes CreateContextRequestEnvVars from json.
func (s *CreateContextRequestEnvVars) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateContextRequestEnvVars to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateContextRequestEnvVars")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateContextRequestEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateContextRequestEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateREPLContextRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateREPLContextRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Language.Set {
			e.FieldStart("language")
			s.Language.Encode(e)
		}
	}
	{
		if s.Input.Set {
			e.FieldStart("input")
			s.Input.Encode(e)
		}
	}
	{
		if s.ReplConfig.Set {
			e.FieldStart("repl_config")
			s.ReplConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateREPLContextRequest = [3]string{
	0: "language",
	1: "input",
	2: "repl_config",
}

// Decode decodes CreateREPLContextRequest from json.
func (s *CreateREPLContextRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateREPLContextRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "language":
			if err := func() error {
				s.Language.Reset()
				if err := s.Language.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"language\"")
			}
		case "input":
			if err := func() error {
				s.Input.Reset()
				if err := s.Input.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"input\"")
			}
		case "repl_config":
			if err := func() error {
				s.ReplConfig.Reset()
				if err := s.ReplConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repl_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateREPLContextRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateREPLContextRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateREPLContextRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSandboxVolumeRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSandboxVolumeRequest) encodeFields(e *jx.Encoder) {
	{
		if s.CacheSize.Set {
			e.FieldStart("cache_size")
			s.CacheSize.Encode(e)
		}
	}
	{
		if s.Prefetch.Set {
			e.FieldStart("prefetch")
			s.Prefetch.Encode(e)
		}
	}
	{
		if s.BufferSize.Set {
			e.FieldStart("buffer_size")
			s.BufferSize.Encode(e)
		}
	}
	{
		if s.Writeback.Set {
			e.FieldStart("writeback")
			s.Writeback.Encode(e)
		}
	}
	{
		if s.AccessMode.Set {
			e.FieldStart("access_mode")
			s.AccessMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSandboxVolumeRequest = [5]string{
	0: "cache_size",
	1: "prefetch",
	2: "buffer_size",
	3: "writeback",
	4: "access_mode",
}

// Decode decodes CreateSandboxVolumeRequest from json.
func (s *CreateSandboxVolumeRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSandboxVolumeRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cache_size":
			if err := func() error {
				s.CacheSize.Reset()
				if err := s.CacheSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_size\"")
			}
		case "prefetch":
			if err := func() error {
				s.Prefetch.Reset()
				if err := s.Prefetch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefetch\"")
			}
		case "buffer_size":
			if err := func() error {
				s.BufferSize.Reset()
				if err := s.BufferSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buffer_size\"")
			}
		case "writeback":
			if err := func() error {
				s.Writeback.Reset()
				if err := s.Writeback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeback\"")
			}
		case "access_mode":
			if err := func() error {
				s.AccessMode.Reset()
				if err := s.AccessMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_mode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSandboxVolumeRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSandboxVolumeRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSandboxVolumeRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSnapshotRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSnapshotRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSnapshotRequest = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes CreateSnapshotRequest from json.
func (s *CreateSnapshotRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSnapshotRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSnapshotRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSnapshotRequest) {
					name = jsonFieldsNameOfCreateSnapshotRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSnapshotRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSnapshotRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateTeamRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateTeamRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateTeamRequest = [2]string{
	0: "name",
	1: "slug",
}

// Decode decodes CreateTeamRequest from json.
func (s *CreateTeamRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateTeamRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateTeamRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateTeamRequest) {
					name = jsonFieldsNameOfCreateTeamRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateTeamRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateTeamRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvVar) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvVar) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEnvVar = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes EnvVar from json.
func (s *EnvVar) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvVar to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvVar")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnvVar) {
					name = jsonFieldsNameOfEnvVar[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvVar) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvVar) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		if len(s.Details) != 0 {
			e.FieldStart("details")
			e.Raw(s.Details)
		}
	}
}

var jsonFieldsNameOfError = [3]string{
	0: "code",
	1: "message",
	2: "details",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "details":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Details = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfError) {
					name = jsonFieldsNameOfError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorEnvelope) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorEnvelope) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		e.FieldStart("error")
		s.Error.Encode(e)
	}
}

var jsonFieldsNameOfErrorEnvelope = [2]string{
	0: "success",
	1: "error",
}

// Decode decodes ErrorEnvelope from json.
func (s *ErrorEnvelope) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorEnvelope to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "error":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorEnvelope")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrorEnvelope) {
					name = jsonFieldsNameOfErrorEnvelope[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorEnvelope) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorEnvelope) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ErrorEnvelopeSuccess as json.
func (s ErrorEnvelopeSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes ErrorEnvelopeSuccess from json.
func (s *ErrorEnvelopeSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorEnvelopeSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = ErrorEnvelopeSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ErrorEnvelopeSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorEnvelopeSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExecCandidate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExecCandidate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Args != nil {
			e.FieldStart("args")
			e.ArrStart()
			for _, elem := range s.Args {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExecCandidate = [2]string{
	0: "name",
	1: "args",
}

// Decode decodes ExecCandidate from json.
func (s *ExecCandidate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExecCandidate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "args":
			if err := func() error {
				s.Args = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Args = append(s.Args, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"args\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExecCandidate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExecCandidate) {
					name = jsonFieldsNameOfExecCandidate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExecCandidate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExecCandidate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExposedPortConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExposedPortConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
	{
		e.FieldStart("resume")
		e.Bool(s.Resume)
	}
	{
		if s.PublicURL.Set {
			e.FieldStart("public_url")
			s.PublicURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfExposedPortConfig = [3]string{
	0: "port",
	1: "resume",
	2: "public_url",
}

// Decode decodes ExposedPortConfig from json.
func (s *ExposedPortConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExposedPortConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "port":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "resume":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Resume = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resume\"")
			}
		case "public_url":
			if err := func() error {
				s.PublicURL.Reset()
				if err := s.PublicURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExposedPortConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfExposedPortConfig) {
					name = jsonFieldsNameOfExposedPortConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExposedPortConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExposedPortConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileContentResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileContentResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Encoding.Set {
			e.FieldStart("encoding")
			s.Encoding.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileContentResponse = [2]string{
	0: "content",
	1: "encoding",
}

// Decode decodes FileContentResponse from json.
func (s *FileContentResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileContentResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "encoding":
			if err := func() error {
				s.Encoding.Reset()
				if err := s.Encoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileContentResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileContentResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileContentResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileContentResponseEncoding as json.
func (s FileContentResponseEncoding) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FileContentResponseEncoding from json.
func (s *FileContentResponseEncoding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileContentResponseEncoding to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FileContentResponseEncoding(v) {
	case FileContentResponseEncodingBase64:
		*s = FileContentResponseEncodingBase64
	default:
		*s = FileContentResponseEncoding(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileContentResponseEncoding) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileContentResponseEncoding) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FileInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FileInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.ModTime.Set {
			e.FieldStart("mod_time")
			s.ModTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.IsLink.Set {
			e.FieldStart("is_link")
			s.IsLink.Encode(e)
		}
	}
	{
		if s.LinkTarget.Set {
			e.FieldStart("link_target")
			s.LinkTarget.Encode(e)
		}
	}
}

var jsonFieldsNameOfFileInfo = [8]string{
	0: "name",
	1: "path",
	2: "type",
	3: "size",
	4: "mode",
	5: "mod_time",
	6: "is_link",
	7: "link_target",
}

// Decode decodes FileInfo from json.
func (s *FileInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "mod_time":
			if err := func() error {
				s.ModTime.Reset()
				if err := s.ModTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mod_time\"")
			}
		case "is_link":
			if err := func() error {
				s.IsLink.Reset()
				if err := s.IsLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_link\"")
			}
		case "link_target":
			if err := func() error {
				s.LinkTarget.Reset()
				if err := s.LinkTarget.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link_target\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FileInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FileInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileInfoType as json.
func (s FileInfoType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes FileInfoType from json.
func (s *FileInfoType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FileInfoType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch FileInfoType(v) {
	case FileInfoTypeFile:
		*s = FileInfoTypeFile
	case FileInfoTypeDir:
		*s = FileInfoTypeDir
	case FileInfoTypeSymlink:
		*s = FileInfoTypeSymlink
	default:
		*s = FileInfoType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FileInfoType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FileInfoType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Identity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Identity) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("provider")
		e.Str(s.Provider)
	}
	{
		e.FieldStart("created_at")
		e.Int64(s.CreatedAt)
	}
}

var jsonFieldsNameOfIdentity = [3]string{
	0: "id",
	1: "provider",
	2: "created_at",
}

// Decode decodes Identity from json.
func (s *Identity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Identity to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Provider = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.CreatedAt = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Identity")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIdentity) {
					name = jsonFieldsNameOfIdentity[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Identity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Identity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LabelSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LabelSelector) encodeFields(e *jx.Encoder) {
	{
		if s.MatchLabels.Set {
			e.FieldStart("matchLabels")
			s.MatchLabels.Encode(e)
		}
	}
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfLabelSelector = [2]string{
	0: "matchLabels",
	1: "matchExpressions",
}

// Decode decodes LabelSelector from json.
func (s *LabelSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabelSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchLabels":
			if err := func() error {
				s.MatchLabels.Reset()
				if err := s.MatchLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchLabels\"")
			}
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]LabelSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LabelSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabelSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LabelSelectorMatchLabels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes LabelSelectorMatchLabels from json.
func (s *LabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabelSelectorMatchLabels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabelSelectorMatchLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LabelSelectorRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LabelSelectorRequirement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfLabelSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes LabelSelectorRequirement from json.
func (s *LabelSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LabelSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LabelSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLabelSelectorRequirement) {
					name = jsonFieldsNameOfLabelSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LabelSelectorRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LabelSelectorRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LifecyclePolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LifecyclePolicy) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultTTL.Set {
			e.FieldStart("defaultTTL")
			s.DefaultTTL.Encode(e)
		}
	}
	{
		if s.MaxTTL.Set {
			e.FieldStart("maxTTL")
			s.MaxTTL.Encode(e)
		}
	}
	{
		if s.IdleTimeout.Set {
			e.FieldStart("idleTimeout")
			s.IdleTimeout.Encode(e)
		}
	}
	{
		if s.PreStop.Set {
			e.FieldStart("preStop")
			s.PreStop.Encode(e)
		}
	}
}

var jsonFieldsNameOfLifecyclePolicy = [4]string{
	0: "defaultTTL",
	1: "maxTTL",
	2: "idleTimeout",
	3: "preStop",
}

// Decode decodes LifecyclePolicy from json.
func (s *LifecyclePolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LifecyclePolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultTTL":
			if err := func() error {
				s.DefaultTTL.Reset()
				if err := s.DefaultTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultTTL\"")
			}
		case "maxTTL":
			if err := func() error {
				s.MaxTTL.Reset()
				if err := s.MaxTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxTTL\"")
			}
		case "idleTimeout":
			if err := func() error {
				s.IdleTimeout.Reset()
				if err := s.IdleTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"idleTimeout\"")
			}
		case "preStop":
			if err := func() error {
				s.PreStop.Reset()
				if err := s.PreStop.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preStop\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LifecyclePolicy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LifecyclePolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LifecyclePolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfLoginRequest = [2]string{
	0: "email",
	1: "password",
}

// Decode decodes LoginRequest from json.
func (s *LoginRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginRequest) {
					name = jsonFieldsNameOfLoginRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("access_token")
		e.Str(s.AccessToken)
	}
	{
		e.FieldStart("refresh_token")
		e.Str(s.RefreshToken)
	}
	{
		e.FieldStart("expires_at")
		e.Int64(s.ExpiresAt)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
}

var jsonFieldsNameOfLoginResponse = [4]string{
	0: "access_token",
	1: "refresh_token",
	2: "expires_at",
	3: "user",
}

// Decode decodes LoginResponse from json.
func (s *LoginResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "refresh_token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RefreshToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.ExpiresAt = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginResponse) {
					name = jsonFieldsNameOfLoginResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MountRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MountRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandboxvolume_id")
		e.Str(s.SandboxvolumeID)
	}
	{
		if s.SandboxID.Set {
			e.FieldStart("sandbox_id")
			s.SandboxID.Encode(e)
		}
	}
	{
		e.FieldStart("mount_point")
		e.Str(s.MountPoint)
	}
	{
		if s.VolumeConfig.Set {
			e.FieldStart("volume_config")
			s.VolumeConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfMountRequest = [4]string{
	0: "sandboxvolume_id",
	1: "sandbox_id",
	2: "mount_point",
	3: "volume_config",
}

// Decode decodes MountRequest from json.
func (s *MountRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MountRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandboxvolume_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxvolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandboxvolume_id\"")
			}
		case "sandbox_id":
			if err := func() error {
				s.SandboxID.Reset()
				if err := s.SandboxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandbox_id\"")
			}
		case "mount_point":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MountPoint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mount_point\"")
			}
		case "volume_config":
			if err := func() error {
				s.VolumeConfig.Reset()
				if err := s.VolumeConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MountRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMountRequest) {
					name = jsonFieldsNameOfMountRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MountRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MountRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MountResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandboxvolume_id")
		e.Str(s.SandboxvolumeID)
	}
	{
		e.FieldStart("mount_point")
		e.Str(s.MountPoint)
	}
	{
		e.FieldStart("mounted_at")
		e.Str(s.MountedAt)
	}
}

var jsonFieldsNameOfMountResponse = [3]string{
	0: "sandboxvolume_id",
	1: "mount_point",
	2: "mounted_at",
}

// Decode decodes MountResponse from json.
func (s *MountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MountResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandboxvolume_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxvolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandboxvolume_id\"")
			}
		case "mount_point":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.MountPoint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mount_point\"")
			}
		case "mounted_at":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.MountedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mounted_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MountResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMountResponse) {
					name = jsonFieldsNameOfMountResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MountStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MountStatus) encodeFields(e *jx.Encoder) {
	{
		if s.SandboxvolumeID.Set {
			e.FieldStart("sandboxvolume_id")
			s.SandboxvolumeID.Encode(e)
		}
	}
	{
		if s.MountPoint.Set {
			e.FieldStart("mount_point")
			s.MountPoint.Encode(e)
		}
	}
	{
		if s.MountedAt.Set {
			e.FieldStart("mounted_at")
			s.MountedAt.Encode(e)
		}
	}
	{
		if s.MountedDurationSec.Set {
			e.FieldStart("mounted_duration_sec")
			s.MountedDurationSec.Encode(e)
		}
	}
}

var jsonFieldsNameOfMountStatus = [4]string{
	0: "sandboxvolume_id",
	1: "mount_point",
	2: "mounted_at",
	3: "mounted_duration_sec",
}

// Decode decodes MountStatus from json.
func (s *MountStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MountStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandboxvolume_id":
			if err := func() error {
				s.SandboxvolumeID.Reset()
				if err := s.SandboxvolumeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandboxvolume_id\"")
			}
		case "mount_point":
			if err := func() error {
				s.MountPoint.Reset()
				if err := s.MountPoint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mount_point\"")
			}
		case "mounted_at":
			if err := func() error {
				s.MountedAt.Reset()
				if err := s.MountedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mounted_at\"")
			}
		case "mounted_duration_sec":
			if err := func() error {
				s.MountedDurationSec.Reset()
				if err := s.MountedDurationSec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mounted_duration_sec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MountStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MountStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MountStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MoveFileRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MoveFileRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		e.Str(s.Source)
	}
	{
		e.FieldStart("destination")
		e.Str(s.Destination)
	}
}

var jsonFieldsNameOfMoveFileRequest = [2]string{
	0: "source",
	1: "destination",
}

// Decode decodes MoveFileRequest from json.
func (s *MoveFileRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MoveFileRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Source = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "destination":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Destination = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MoveFileRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMoveFileRequest) {
					name = jsonFieldsNameOfMoveFileRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MoveFileRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MoveFileRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NetworkEgressPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NetworkEgressPolicy) encodeFields(e *jx.Encoder) {
	{
		if s.AllowedCidrs != nil {
			e.FieldStart("allowedCidrs")
			e.ArrStart()
			for _, elem := range s.AllowedCidrs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedDomains != nil {
			e.FieldStart("allowedDomains")
			e.ArrStart()
			for _, elem := range s.AllowedDomains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AllowedPorts != nil {
			e.FieldStart("allowedPorts")
			e.ArrStart()
			for _, elem := range s.AllowedPorts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DeniedDomains != nil {
			e.FieldStart("deniedDomains")
			e.ArrStart()
			for _, elem := range s.DeniedDomains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DeniedCidrs != nil {
			e.FieldStart("deniedCidrs")
			e.ArrStart()
			for _, elem := range s.DeniedCidrs {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DeniedPorts != nil {
			e.FieldStart("deniedPorts")
			e.ArrStart()
			for _, elem := range s.DeniedPorts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNetworkEgressPolicy = [6]string{
	0: "allowedCidrs",
	1: "allowedDomains",
	2: "allowedPorts",
	3: "deniedDomains",
	4: "deniedCidrs",
	5: "deniedPorts",
}

// Decode decodes NetworkEgressPolicy from json.
func (s *NetworkEgressPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NetworkEgressPolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allowedCidrs":
			if err := func() error {
				s.AllowedCidrs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedCidrs = append(s.AllowedCidrs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedCidrs\"")
			}
		case "allowedDomains":
			if err := func() error {
				s.AllowedDomains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedDomains = append(s.AllowedDomains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedDomains\"")
			}
		case "allowedPorts":
			if err := func() error {
				s.AllowedPorts = make([]PortSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PortSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllowedPorts = append(s.AllowedPorts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedPorts\"")
			}
		case "deniedDomains":
			if err := func() error {
				s.DeniedDomains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DeniedDomains = append(s.DeniedDomains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deniedDomains\"")
			}
		case "deniedCidrs":
			if err := func() error {
				s.DeniedCidrs = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DeniedCidrs = append(s.DeniedCidrs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deniedCidrs\"")
			}
		case "deniedPorts":
			if err := func() error {
				s.DeniedPorts = make([]PortSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PortSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DeniedPorts = append(s.DeniedPorts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deniedPorts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NetworkEgressPolicy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NetworkEgressPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NetworkEgressPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution.Set {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			s.RequiredDuringSchedulingIgnoredDuringExecution.Encode(e)
		}
	}
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodeAffinity = [2]string{
	0: "requiredDuringSchedulingIgnoredDuringExecution",
	1: "preferredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes NodeAffinity from json.
func (s *NodeAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution.Reset()
				if err := s.RequiredDuringSchedulingIgnoredDuringExecution.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]PreferredSchedulingTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PreferredSchedulingTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeSelector) encodeFields(e *jx.Encoder) {
	{
		if s.NodeSelectorTerms != nil {
			e.FieldStart("nodeSelectorTerms")
			e.ArrStart()
			for _, elem := range s.NodeSelectorTerms {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodeSelector = [1]string{
	0: "nodeSelectorTerms",
}

// Decode decodes NodeSelector from json.
func (s *NodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeSelector to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelectorTerms":
			if err := func() error {
				s.NodeSelectorTerms = make([]NodeSelectorTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodeSelectorTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeSelectorTerms = append(s.NodeSelectorTerms, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelectorTerms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeSelectorRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeSelectorRequirement) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("operator")
		e.Str(s.Operator)
	}
	{
		if s.Values != nil {
			e.FieldStart("values")
			e.ArrStart()
			for _, elem := range s.Values {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodeSelectorRequirement = [3]string{
	0: "key",
	1: "operator",
	2: "values",
}

// Decode decodes NodeSelectorRequirement from json.
func (s *NodeSelectorRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeSelectorRequirement to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Operator = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "values":
			if err := func() error {
				s.Values = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Values = append(s.Values, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"values\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeSelectorRequirement")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNodeSelectorRequirement) {
					name = jsonFieldsNameOfNodeSelectorRequirement[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeSelectorRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeSelectorRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeSelectorTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeSelectorTerm) encodeFields(e *jx.Encoder) {
	{
		if s.MatchExpressions != nil {
			e.FieldStart("matchExpressions")
			e.ArrStart()
			for _, elem := range s.MatchExpressions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MatchFields != nil {
			e.FieldStart("matchFields")
			e.ArrStart()
			for _, elem := range s.MatchFields {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodeSelectorTerm = [2]string{
	0: "matchExpressions",
	1: "matchFields",
}

// Decode decodes NodeSelectorTerm from json.
func (s *NodeSelectorTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeSelectorTerm to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchExpressions":
			if err := func() error {
				s.MatchExpressions = make([]NodeSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodeSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchExpressions = append(s.MatchExpressions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchExpressions\"")
			}
		case "matchFields":
			if err := func() error {
				s.MatchFields = make([]NodeSelectorRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodeSelectorRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchFields = append(s.MatchFields, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchFields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeSelectorTerm")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeSelectorTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeSelectorTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Affinity as json.
func (o OptAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Affinity from json.
func (o *OptAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Capabilities as json.
func (o OptCapabilities) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Capabilities from json.
func (o *OptCapabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCapabilities to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClaimResponse as json.
func (o OptClaimResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClaimResponse from json.
func (o *OptClaimResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClaimResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClaimResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClaimResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContainerSpec as json.
func (o OptContainerSpec) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContainerSpec from json.
func (o *OptContainerSpec) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContainerSpec to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContainerSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContainerSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContextExecResponse as json.
func (o OptContextExecResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContextExecResponse from json.
func (o *OptContextExecResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContextExecResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContextExecResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContextExecResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContextResponse as json.
func (o OptContextResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContextResponse from json.
func (o *OptContextResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContextResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContextResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContextResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContextResponseEnvVars as json.
func (o OptContextResponseEnvVars) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContextResponseEnvVars from json.
func (o *OptContextResponseEnvVars) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContextResponseEnvVars to nil")
	}
	o.Set = true
	o.Value = make(ContextResponseEnvVars)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContextResponseEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContextResponseEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContextStatsResponse as json.
func (o OptContextStatsResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContextStatsResponse from json.
func (o *OptContextStatsResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContextStatsResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContextStatsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContextStatsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAPIKeyResponse as json.
func (o OptCreateAPIKeyResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateAPIKeyResponse from json.
func (o *OptCreateAPIKeyResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateAPIKeyResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateAPIKeyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateAPIKeyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateCMDContextRequest as json.
func (o OptCreateCMDContextRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateCMDContextRequest from json.
func (o *OptCreateCMDContextRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateCMDContextRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateCMDContextRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateCMDContextRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateContextRequestEnvVars as json.
func (o OptCreateContextRequestEnvVars) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateContextRequestEnvVars from json.
func (o *OptCreateContextRequestEnvVars) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateContextRequestEnvVars to nil")
	}
	o.Set = true
	o.Value = make(CreateContextRequestEnvVars)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateContextRequestEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateContextRequestEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateREPLContextRequest as json.
func (o OptCreateREPLContextRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateREPLContextRequest from json.
func (o *OptCreateREPLContextRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateREPLContextRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateREPLContextRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateREPLContextRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes FileContentResponse as json.
func (o OptFileContentResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileContentResponse from json.
func (o *OptFileContentResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileContentResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileContentResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileContentResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileContentResponseEncoding as json.
func (o OptFileContentResponseEncoding) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FileContentResponseEncoding from json.
func (o *OptFileContentResponseEncoding) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileContentResponseEncoding to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileContentResponseEncoding) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileContentResponseEncoding) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileInfo as json.
func (o OptFileInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FileInfo from json.
func (o *OptFileInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FileInfoType as json.
func (o OptFileInfoType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes FileInfoType from json.
func (o *OptFileInfoType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFileInfoType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFileInfoType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFileInfoType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LabelSelector as json.
func (o OptLabelSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LabelSelector from json.
func (o *OptLabelSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLabelSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLabelSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLabelSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LabelSelectorMatchLabels as json.
func (o OptLabelSelectorMatchLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LabelSelectorMatchLabels from json.
func (o *OptLabelSelectorMatchLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLabelSelectorMatchLabels to nil")
	}
	o.Set = true
	o.Value = make(LabelSelectorMatchLabels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLabelSelectorMatchLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLabelSelectorMatchLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LifecyclePolicy as json.
func (o OptLifecyclePolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LifecyclePolicy from json.
func (o *OptLifecyclePolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLifecyclePolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLifecyclePolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLifecyclePolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoginResponse as json.
func (o OptLoginResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LoginResponse from json.
func (o *OptLoginResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoginResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoginResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoginResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MountResponse as json.
func (o OptMountResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MountResponse from json.
func (o *OptMountResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMountResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NetworkEgressPolicy as json.
func (o OptNetworkEgressPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NetworkEgressPolicy from json.
func (o *OptNetworkEgressPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNetworkEgressPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNetworkEgressPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNetworkEgressPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeAffinity as json.
func (o OptNodeAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NodeAffinity from json.
func (o *OptNodeAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeSelector as json.
func (o OptNodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NodeSelector from json.
func (o *OptNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeSelector to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PTYSize as json.
func (o OptPTYSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PTYSize from json.
func (o *OptPTYSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPTYSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPTYSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPTYSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PauseSandboxResponse as json.
func (o OptPauseSandboxResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PauseSandboxResponse from json.
func (o *OptPauseSandboxResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPauseSandboxResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPauseSandboxResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPauseSandboxResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PodAffinity as json.
func (o OptPodAffinity) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PodAffinity from json.
func (o *OptPodAffinity) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPodAffinity to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPodAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPodAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PodSpecOverride as json.
func (o OptPodSpecOverride) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PodSpecOverride from json.
func (o *OptPodSpecOverride) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPodSpecOverride to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPodSpecOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPodSpecOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PodSpecOverrideNodeSelector as json.
func (o OptPodSpecOverrideNodeSelector) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PodSpecOverrideNodeSelector from json.
func (o *OptPodSpecOverrideNodeSelector) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPodSpecOverrideNodeSelector to nil")
	}
	o.Set = true
	o.Value = make(PodSpecOverrideNodeSelector)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPodSpecOverrideNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPodSpecOverrideNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolStrategy as json.
func (o OptPoolStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolStrategy from json.
func (o *OptPoolStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PreStopHook as json.
func (o OptPreStopHook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PreStopHook from json.
func (o *OptPreStopHook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPreStopHook to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPreStopHook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPreStopHook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessType as json.
func (o OptProcessType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProcessType from json.
func (o *OptProcessType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProcessType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProcessType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProcessType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes REPLConfig as json.
func (o OptREPLConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes REPLConfig from json.
func (o *OptREPLConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptREPLConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptREPLConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptREPLConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes REPLPromptConfig as json.
func (o OptREPLPromptConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes REPLPromptConfig from json.
func (o *OptREPLPromptConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptREPLPromptConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptREPLPromptConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptREPLPromptConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes REPLReadyConfig as json.
func (o OptREPLReadyConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes REPLReadyConfig from json.
func (o *OptREPLReadyConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptREPLReadyConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptREPLReadyConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptREPLReadyConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes REPLReadyMode as json.
func (o OptREPLReadyMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes REPLReadyMode from json.
func (o *OptREPLReadyMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptREPLReadyMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptREPLReadyMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptREPLReadyMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefreshRequest as json.
func (o OptRefreshRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RefreshRequest from json.
func (o *OptRefreshRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRefreshRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRefreshRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRefreshRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RefreshResponse as json.
func (o OptRefreshResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RefreshResponse from json.
func (o *OptRefreshResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRefreshResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRefreshResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRefreshResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegistryCredentials as json.
func (o OptRegistryCredentials) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RegistryCredentials from json.
func (o *OptRegistryCredentials) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegistryCredentials to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegistryCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegistryCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResourceUsage as json.
func (o OptResourceUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResourceUsage from json.
func (o *OptResourceUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResourceUsage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResourceUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResourceUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResumeSandboxResponse as json.
func (o OptResumeSandboxResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResumeSandboxResponse from json.
func (o *OptResumeSandboxResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResumeSandboxResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResumeSandboxResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResumeSandboxResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Sandbox as json.
func (o OptSandbox) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Sandbox from json.
func (o *OptSandbox) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandbox to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSandbox) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSandbox) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SandboxConfig as json.
func (o OptSandboxConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxConfig from json.
func (o *OptSandboxConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandboxConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSandboxConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSandboxConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SandboxConfigEnvVars as json.
func (o OptSandboxConfigEnvVars) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxConfigEnvVars from json.
func (o *OptSandboxConfigEnvVars) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandboxConfigEnvVars to nil")
	}
	o.Set = true
	o.Value = make(SandboxConfigEnvVars)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSandboxConfigEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSandboxConfigEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SandboxResourceUsage as json.
func (o OptSandboxResourceUsage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxResourceUsage from json.
func (o *OptSandboxResourceUsage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandboxResourceUsage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSandboxResourceUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSandboxResourceUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SandboxStatus as json.
func (o OptSandboxStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxStatus from json.
func (o *OptSandboxStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandboxStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSandboxStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSandboxStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SandboxTemplateSpecEnvVars as json.
func (o OptSandboxTemplateSpecEnvVars) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxTemplateSpecEnvVars from json.
func (o *OptSandboxTemplateSpecEnvVars) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandboxTemplateSpecEnvVars to nil")
	}
	o.Set = true
	o.Value = make(SandboxTemplateSpecEnvVars)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSandboxTemplateSpecEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSandboxTemplateSpecEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SandboxVolume as json.
func (o OptSandboxVolume) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SandboxVolume from json.
func (o *OptSandboxVolume) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSandboxVolume to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSandboxVolume) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSandboxVolume) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecurityContext as json.
func (o OptSecurityContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SecurityContext from json.
func (o *OptSecurityContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecurityContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Snapshot as json.
func (o OptSnapshot) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Snapshot from json.
func (o *OptSnapshot) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSnapshot to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSnapshot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSnapshot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessAPIKeyListResponseData as json.
func (o OptSuccessAPIKeyListResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessAPIKeyListResponseData from json.
func (o *OptSuccessAPIKeyListResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessAPIKeyListResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessAPIKeyListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessAPIKeyListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessAuthProvidersResponseData as json.
func (o OptSuccessAuthProvidersResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessAuthProvidersResponseData from json.
func (o *OptSuccessAuthProvidersResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessAuthProvidersResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessAuthProvidersResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessAuthProvidersResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessContextListResponseData as json.
func (o OptSuccessContextListResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessContextListResponseData from json.
func (o *OptSuccessContextListResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessContextListResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessContextListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessContextListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessCreatedResponseData as json.
func (o OptSuccessCreatedResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessCreatedResponseData from json.
func (o *OptSuccessCreatedResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessCreatedResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessCreatedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessCreatedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessDeletedResponseData as json.
func (o OptSuccessDeletedResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessDeletedResponseData from json.
func (o *OptSuccessDeletedResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessDeletedResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessDeletedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessDeletedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessExposedPortsResponseData as json.
func (o OptSuccessExposedPortsResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessExposedPortsResponseData from json.
func (o *OptSuccessExposedPortsResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessExposedPortsResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessExposedPortsResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessExposedPortsResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessFileListResponseData as json.
func (o OptSuccessFileListResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessFileListResponseData from json.
func (o *OptSuccessFileListResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessFileListResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessFileListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessFileListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessHealthResponseData as json.
func (o OptSuccessHealthResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessHealthResponseData from json.
func (o *OptSuccessHealthResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessHealthResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessHealthResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessHealthResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessIdentityListResponseData as json.
func (o OptSuccessIdentityListResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessIdentityListResponseData from json.
func (o *OptSuccessIdentityListResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessIdentityListResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessIdentityListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessIdentityListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessMessageResponseData as json.
func (o OptSuccessMessageResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessMessageResponseData from json.
func (o *OptSuccessMessageResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessMessageResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessMessageResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessMessageResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessMountStatusResponseData as json.
func (o OptSuccessMountStatusResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessMountStatusResponseData from json.
func (o *OptSuccessMountStatusResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessMountStatusResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessMountStatusResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessMountStatusResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessMovedResponseData as json.
func (o OptSuccessMovedResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessMovedResponseData from json.
func (o *OptSuccessMovedResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessMovedResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessMovedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessMovedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessResizedResponseData as json.
func (o OptSuccessResizedResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessResizedResponseData from json.
func (o *OptSuccessResizedResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessResizedResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessResizedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessResizedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessRestoreResponseData as json.
func (o OptSuccessRestoreResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessRestoreResponseData from json.
func (o *OptSuccessRestoreResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessRestoreResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessRestoreResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessRestoreResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSignaledResponseData as json.
func (o OptSuccessSignaledResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessSignaledResponseData from json.
func (o *OptSuccessSignaledResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessSignaledResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessSignaledResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessSignaledResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTeamListResponseData as json.
func (o OptSuccessTeamListResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessTeamListResponseData from json.
func (o *OptSuccessTeamListResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessTeamListResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessTeamListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessTeamListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTeamMemberListResponseData as json.
func (o OptSuccessTeamMemberListResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessTeamMemberListResponseData from json.
func (o *OptSuccessTeamMemberListResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessTeamMemberListResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessTeamMemberListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessTeamMemberListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTemplateListResponseData as json.
func (o OptSuccessTemplateListResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessTemplateListResponseData from json.
func (o *OptSuccessTemplateListResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessTemplateListResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessTemplateListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessTemplateListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessUnmountedResponseData as json.
func (o OptSuccessUnmountedResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessUnmountedResponseData from json.
func (o *OptSuccessUnmountedResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessUnmountedResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessUnmountedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessUnmountedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessWrittenResponseData as json.
func (o OptSuccessWrittenResponseData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SuccessWrittenResponseData from json.
func (o *OptSuccessWrittenResponseData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSuccessWrittenResponseData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSuccessWrittenResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSuccessWrittenResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Team as json.
func (o OptTeam) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Team from json.
func (o *OptTeam) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeam to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeam) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeam) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamMember as json.
func (o OptTeamMember) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TeamMember from json.
func (o *OptTeamMember) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTeamMember to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTeamMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTeamMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Template as json.
func (o OptTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Template from json.
func (o *OptTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TplSandboxNetworkPolicy as json.
func (o OptTplSandboxNetworkPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TplSandboxNetworkPolicy from json.
func (o *OptTplSandboxNetworkPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTplSandboxNetworkPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTplSandboxNetworkPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTplSandboxNetworkPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes User as json.
func (o OptUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes User from json.
func (o *OptUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeAccessMode as json.
func (o OptVolumeAccessMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VolumeAccessMode from json.
func (o *OptVolumeAccessMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVolumeAccessMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVolumeAccessMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVolumeAccessMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeConfig as json.
func (o OptVolumeConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VolumeConfig from json.
func (o *OptVolumeConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVolumeConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVolumeConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVolumeConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WebhookConfig as json.
func (o OptWebhookConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WebhookConfig from json.
func (o *OptWebhookConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWebhookConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWebhookConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWebhookConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PTYSize) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PTYSize) encodeFields(e *jx.Encoder) {
	{
		if s.Rows.Set {
			e.FieldStart("rows")
			s.Rows.Encode(e)
		}
	}
	{
		if s.Cols.Set {
			e.FieldStart("cols")
			s.Cols.Encode(e)
		}
	}
}

var jsonFieldsNameOfPTYSize = [2]string{
	0: "rows",
	1: "cols",
}

// Decode decodes PTYSize from json.
func (s *PTYSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PTYSize to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rows":
			if err := func() error {
				s.Rows.Reset()
				if err := s.Rows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rows\"")
			}
		case "cols":
			if err := func() error {
				s.Cols.Reset()
				if err := s.Cols.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cols\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PTYSize")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PTYSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PTYSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PauseSandboxResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PauseSandboxResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandbox_id")
		e.Str(s.SandboxID)
	}
	{
		e.FieldStart("paused")
		e.Bool(s.Paused)
	}
	{
		if s.ResourceUsage.Set {
			e.FieldStart("resource_usage")
			s.ResourceUsage.Encode(e)
		}
	}
	{
		if s.UpdatedMemory.Set {
			e.FieldStart("updated_memory")
			s.UpdatedMemory.Encode(e)
		}
	}
	{
		if s.UpdatedCPU.Set {
			e.FieldStart("updated_cpu")
			s.UpdatedCPU.Encode(e)
		}
	}
}

var jsonFieldsNameOfPauseSandboxResponse = [5]string{
	0: "sandbox_id",
	1: "paused",
	2: "resource_usage",
	3: "updated_memory",
	4: "updated_cpu",
}

// Decode decodes PauseSandboxResponse from json.
func (s *PauseSandboxResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PauseSandboxResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandbox_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandbox_id\"")
			}
		case "paused":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Paused = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "resource_usage":
			if err := func() error {
				s.ResourceUsage.Reset()
				if err := s.ResourceUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource_usage\"")
			}
		case "updated_memory":
			if err := func() error {
				s.UpdatedMemory.Reset()
				if err := s.UpdatedMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_memory\"")
			}
		case "updated_cpu":
			if err := func() error {
				s.UpdatedCPU.Reset()
				if err := s.UpdatedCPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_cpu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PauseSandboxResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPauseSandboxResponse) {
					name = jsonFieldsNameOfPauseSandboxResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PauseSandboxResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PauseSandboxResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PodAffinity) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PodAffinity) encodeFields(e *jx.Encoder) {
	{
		if s.RequiredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("requiredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.RequiredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PreferredDuringSchedulingIgnoredDuringExecution != nil {
			e.FieldStart("preferredDuringSchedulingIgnoredDuringExecution")
			e.ArrStart()
			for _, elem := range s.PreferredDuringSchedulingIgnoredDuringExecution {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPodAffinity = [2]string{
	0: "requiredDuringSchedulingIgnoredDuringExecution",
	1: "preferredDuringSchedulingIgnoredDuringExecution",
}

// Decode decodes PodAffinity from json.
func (s *PodAffinity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PodAffinity to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requiredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.RequiredDuringSchedulingIgnoredDuringExecution = make([]PodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RequiredDuringSchedulingIgnoredDuringExecution = append(s.RequiredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requiredDuringSchedulingIgnoredDuringExecution\"")
			}
		case "preferredDuringSchedulingIgnoredDuringExecution":
			if err := func() error {
				s.PreferredDuringSchedulingIgnoredDuringExecution = make([]WeightedPodAffinityTerm, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem WeightedPodAffinityTerm
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PreferredDuringSchedulingIgnoredDuringExecution = append(s.PreferredDuringSchedulingIgnoredDuringExecution, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preferredDuringSchedulingIgnoredDuringExecution\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PodAffinity")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PodAffinity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PodAffinity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PodAffinityTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PodAffinityTerm) encodeFields(e *jx.Encoder) {
	{
		if s.LabelSelector.Set {
			e.FieldStart("labelSelector")
			s.LabelSelector.Encode(e)
		}
	}
	{
		if s.Namespaces != nil {
			e.FieldStart("namespaces")
			e.ArrStart()
			for _, elem := range s.Namespaces {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("topologyKey")
		e.Str(s.TopologyKey)
	}
}

var jsonFieldsNameOfPodAffinityTerm = [3]string{
	0: "labelSelector",
	1: "namespaces",
	2: "topologyKey",
}

// Decode decodes PodAffinityTerm from json.
func (s *PodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "labelSelector":
			if err := func() error {
				s.LabelSelector.Reset()
				if err := s.LabelSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labelSelector\"")
			}
		case "namespaces":
			if err := func() error {
				s.Namespaces = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Namespaces = append(s.Namespaces, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespaces\"")
			}
		case "topologyKey":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TopologyKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topologyKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPodAffinityTerm) {
					name = jsonFieldsNameOfPodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PodAffinityTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PodAffinityTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PodSpecOverride) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PodSpecOverride) encodeFields(e *jx.Encoder) {
	{
		if s.NodeSelector.Set {
			e.FieldStart("nodeSelector")
			s.NodeSelector.Encode(e)
		}
	}
	{
		if s.Affinity.Set {
			e.FieldStart("affinity")
			s.Affinity.Encode(e)
		}
	}
	{
		if s.Tolerations != nil {
			e.FieldStart("tolerations")
			e.ArrStart()
			for _, elem := range s.Tolerations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ServiceAccountName.Set {
			e.FieldStart("serviceAccountName")
			s.ServiceAccountName.Encode(e)
		}
	}
}

var jsonFieldsNameOfPodSpecOverride = [4]string{
	0: "nodeSelector",
	1: "affinity",
	2: "tolerations",
	3: "serviceAccountName",
}

// Decode decodes PodSpecOverride from json.
func (s *PodSpecOverride) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PodSpecOverride to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeSelector":
			if err := func() error {
				s.NodeSelector.Reset()
				if err := s.NodeSelector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeSelector\"")
			}
		case "affinity":
			if err := func() error {
				s.Affinity.Reset()
				if err := s.Affinity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affinity\"")
			}
		case "tolerations":
			if err := func() error {
				s.Tolerations = make([]Toleration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Toleration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tolerations = append(s.Tolerations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tolerations\"")
			}
		case "serviceAccountName":
			if err := func() error {
				s.ServiceAccountName.Reset()
				if err := s.ServiceAccountName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceAccountName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PodSpecOverride")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PodSpecOverride) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PodSpecOverride) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PodSpecOverrideNodeSelector) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PodSpecOverrideNodeSelector) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes PodSpecOverrideNodeSelector from json.
func (s *PodSpecOverrideNodeSelector) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PodSpecOverrideNodeSelector to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PodSpecOverrideNodeSelector")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PodSpecOverrideNodeSelector) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PodSpecOverrideNodeSelector) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolStrategy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("minIdle")
		e.Int32(s.MinIdle)
	}
	{
		e.FieldStart("maxIdle")
		e.Int32(s.MaxIdle)
	}
	{
		e.FieldStart("autoScale")
		e.Bool(s.AutoScale)
	}
}

var jsonFieldsNameOfPoolStrategy = [3]string{
	0: "minIdle",
	1: "maxIdle",
	2: "autoScale",
}

// Decode decodes PoolStrategy from json.
func (s *PoolStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolStrategy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "minIdle":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.MinIdle = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minIdle\"")
			}
		case "maxIdle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.MaxIdle = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxIdle\"")
			}
		case "autoScale":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.AutoScale = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoScale\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolStrategy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPoolStrategy) {
					name = jsonFieldsNameOfPoolStrategy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PortSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PortSpec) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("port")
		e.Int32(s.Port)
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.EndPort.Set {
			e.FieldStart("endPort")
			s.EndPort.Encode(e)
		}
	}
}

var jsonFieldsNameOfPortSpec = [3]string{
	0: "port",
	1: "protocol",
	2: "endPort",
}

// Decode decodes PortSpec from json.
func (s *PortSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PortSpec to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "port":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Port = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "endPort":
			if err := func() error {
				s.EndPort.Reset()
				if err := s.EndPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endPort\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PortSpec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPortSpec) {
					name = jsonFieldsNameOfPortSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PortSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PortSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreStopHook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreStopHook) encodeFields(e *jx.Encoder) {
	{
		if s.Command != nil {
			e.FieldStart("command")
			e.ArrStart()
			for _, elem := range s.Command {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TimeoutSeconds.Set {
			e.FieldStart("timeoutSeconds")
			s.TimeoutSeconds.Encode(e)
		}
	}
}

var jsonFieldsNameOfPreStopHook = [2]string{
	0: "command",
	1: "timeoutSeconds",
}

// Decode decodes PreStopHook from json.
func (s *PreStopHook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreStopHook to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "command":
			if err := func() error {
				s.Command = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Command = append(s.Command, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		case "timeoutSeconds":
			if err := func() error {
				s.TimeoutSeconds.Reset()
				if err := s.TimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeoutSeconds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreStopHook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreStopHook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreStopHook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PreferredSchedulingTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PreferredSchedulingTerm) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("weight")
		e.Int32(s.Weight)
	}
	{
		e.FieldStart("preference")
		s.Preference.Encode(e)
	}
}

var jsonFieldsNameOfPreferredSchedulingTerm = [2]string{
	0: "weight",
	1: "preference",
}

// Decode decodes PreferredSchedulingTerm from json.
func (s *PreferredSchedulingTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PreferredSchedulingTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weight":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "preference":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Preference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PreferredSchedulingTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPreferredSchedulingTerm) {
					name = jsonFieldsNameOfPreferredSchedulingTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PreferredSchedulingTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PreferredSchedulingTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProcessType as json.
func (s ProcessType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProcessType from json.
func (s *ProcessType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProcessType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProcessType(v) {
	case ProcessTypeRepl:
		*s = ProcessTypeRepl
	case ProcessTypeCmd:
		*s = ProcessTypeCmd
	default:
		*s = ProcessType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProcessType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProcessType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *REPLConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *REPLConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("display_name")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("candidates")
		e.ArrStart()
		for _, elem := range s.Candidates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.Env != nil {
			e.FieldStart("env")
			e.ArrStart()
			for _, elem := range s.Env {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultTerm.Set {
			e.FieldStart("default_term")
			s.DefaultTerm.Encode(e)
		}
	}
	{
		if s.Prompt.Set {
			e.FieldStart("prompt")
			s.Prompt.Encode(e)
		}
	}
	{
		if s.Ready.Set {
			e.FieldStart("ready")
			s.Ready.Encode(e)
		}
	}
}

var jsonFieldsNameOfREPLConfig = [8]string{
	0: "name",
	1: "display_name",
	2: "description",
	3: "candidates",
	4: "env",
	5: "default_term",
	6: "prompt",
	7: "ready",
}

// Decode decodes REPLConfig from json.
func (s *REPLConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode REPLConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "display_name":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "candidates":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Candidates = make([]ExecCandidate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExecCandidate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Candidates = append(s.Candidates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"candidates\"")
			}
		case "env":
			if err := func() error {
				s.Env = make([]REPLEnvVar, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem REPLEnvVar
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Env = append(s.Env, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env\"")
			}
		case "default_term":
			if err := func() error {
				s.DefaultTerm.Reset()
				if err := s.DefaultTerm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_term\"")
			}
		case "prompt":
			if err := func() error {
				s.Prompt.Reset()
				if err := s.Prompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prompt\"")
			}
		case "ready":
			if err := func() error {
				s.Ready.Reset()
				if err := s.Ready.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ready\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode REPLConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfREPLConfig) {
					name = jsonFieldsNameOfREPLConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *REPLConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *REPLConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *REPLEnvVar) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *REPLEnvVar) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.ValueFrom.Set {
			e.FieldStart("value_from")
			s.ValueFrom.Encode(e)
		}
	}
}

var jsonFieldsNameOfREPLEnvVar = [3]string{
	0: "name",
	1: "value",
	2: "value_from",
}

// Decode decodes REPLEnvVar from json.
func (s *REPLEnvVar) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode REPLEnvVar to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "value_from":
			if err := func() error {
				s.ValueFrom.Reset()
				if err := s.ValueFrom.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value_from\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode REPLEnvVar")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfREPLEnvVar) {
					name = jsonFieldsNameOfREPLEnvVar[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *REPLEnvVar) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *REPLEnvVar) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *REPLPromptConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *REPLPromptConfig) encodeFields(e *jx.Encoder) {
	{
		if s.CustomPrompt.Set {
			e.FieldStart("custom_prompt")
			s.CustomPrompt.Encode(e)
		}
	}
}

var jsonFieldsNameOfREPLPromptConfig = [1]string{
	0: "custom_prompt",
}

// Decode decodes REPLPromptConfig from json.
func (s *REPLPromptConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode REPLPromptConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "custom_prompt":
			if err := func() error {
				s.CustomPrompt.Reset()
				if err := s.CustomPrompt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"custom_prompt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode REPLPromptConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *REPLPromptConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *REPLPromptConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *REPLReadyConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *REPLReadyConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Token.Set {
			e.FieldStart("token")
			s.Token.Encode(e)
		}
	}
	{
		if s.StartupDelayMs.Set {
			e.FieldStart("startup_delay_ms")
			s.StartupDelayMs.Encode(e)
		}
	}
}

var jsonFieldsNameOfREPLReadyConfig = [3]string{
	0: "mode",
	1: "token",
	2: "startup_delay_ms",
}

// Decode decodes REPLReadyConfig from json.
func (s *REPLReadyConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode REPLReadyConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "token":
			if err := func() error {
				s.Token.Reset()
				if err := s.Token.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "startup_delay_ms":
			if err := func() error {
				s.StartupDelayMs.Reset()
				if err := s.StartupDelayMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startup_delay_ms\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode REPLReadyConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *REPLReadyConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *REPLReadyConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes REPLReadyMode as json.
func (s REPLReadyMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes REPLReadyMode from json.
func (s *REPLReadyMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode REPLReadyMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch REPLReadyMode(v) {
	case REPLReadyModePromptToken:
		*s = REPLReadyModePromptToken
	case REPLReadyModeStartupDelay:
		*s = REPLReadyModeStartupDelay
	default:
		*s = REPLReadyMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s REPLReadyMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *REPLReadyMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RefreshRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RefreshRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("refresh_token")
		e.Str(s.RefreshToken)
	}
}

var jsonFieldsNameOfRefreshRequest = [1]string{
	0: "refresh_token",
}

// Decode decodes RefreshRequest from json.
func (s *RefreshRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "refresh_token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RefreshToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh_token\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RefreshRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRefreshRequest) {
					name = jsonFieldsNameOfRefreshRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RefreshResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RefreshResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandbox_id")
		e.Str(s.SandboxID)
	}
	{
		e.FieldStart("expires_at")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
}

var jsonFieldsNameOfRefreshResponse = [2]string{
	0: "sandbox_id",
	1: "expires_at",
}

// Decode decodes RefreshResponse from json.
func (s *RefreshResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RefreshResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandbox_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandbox_id\"")
			}
		case "expires_at":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RefreshResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRefreshResponse) {
					name = jsonFieldsNameOfRefreshResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RefreshResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RefreshResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfRegisterRequest = [3]string{
	0: "email",
	1: "password",
	2: "name",
}

// Decode decodes RegisterRequest from json.
func (s *RegisterRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterRequest) {
					name = jsonFieldsNameOfRegisterRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegistryCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegistryCredentials) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("provider")
		e.Str(s.Provider)
	}
	{
		e.FieldStart("registry")
		e.Str(s.Registry)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expiresAt")
			s.ExpiresAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfRegistryCredentials = [5]string{
	0: "provider",
	1: "registry",
	2: "username",
	3: "password",
	4: "expiresAt",
}

// Decode decodes RegistryCredentials from json.
func (s *RegistryCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegistryCredentials to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Provider = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "registry":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Registry = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registry\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "expiresAt":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegistryCredentials")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegistryCredentials) {
					name = jsonFieldsNameOfRegistryCredentials[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegistryCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegistryCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResizeContextRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResizeContextRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rows")
		e.Int32(s.Rows)
	}
	{
		e.FieldStart("cols")
		e.Int32(s.Cols)
	}
}

var jsonFieldsNameOfResizeContextRequest = [2]string{
	0: "rows",
	1: "cols",
}

// Decode decodes ResizeContextRequest from json.
func (s *ResizeContextRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResizeContextRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Rows = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rows\"")
			}
		case "cols":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Cols = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cols\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResizeContextRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResizeContextRequest) {
					name = jsonFieldsNameOfResizeContextRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResizeContextRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResizeContextRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceQuota) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceQuota) encodeFields(e *jx.Encoder) {
	{
		if s.CPU.Set {
			e.FieldStart("cpu")
			s.CPU.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("memory")
			s.Memory.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceQuota = [2]string{
	0: "cpu",
	1: "memory",
}

// Decode decodes ResourceQuota from json.
func (s *ResourceQuota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceQuota to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu":
			if err := func() error {
				s.CPU.Reset()
				if err := s.CPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		case "memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceQuota")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceQuota) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceQuota) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResourceUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResourceUsage) encodeFields(e *jx.Encoder) {
	{
		if s.CPUPercent.Set {
			e.FieldStart("cpu_percent")
			s.CPUPercent.Encode(e)
		}
	}
	{
		if s.MemoryRss.Set {
			e.FieldStart("memory_rss")
			s.MemoryRss.Encode(e)
		}
	}
	{
		if s.MemoryVms.Set {
			e.FieldStart("memory_vms")
			s.MemoryVms.Encode(e)
		}
	}
	{
		if s.OpenFiles.Set {
			e.FieldStart("open_files")
			s.OpenFiles.Encode(e)
		}
	}
	{
		if s.ThreadCount.Set {
			e.FieldStart("thread_count")
			s.ThreadCount.Encode(e)
		}
	}
	{
		if s.ContainerMemoryUsage.Set {
			e.FieldStart("container_memory_usage")
			s.ContainerMemoryUsage.Encode(e)
		}
	}
	{
		if s.ContainerMemoryLimit.Set {
			e.FieldStart("container_memory_limit")
			s.ContainerMemoryLimit.Encode(e)
		}
	}
	{
		if s.ContainerMemoryWorkingSet.Set {
			e.FieldStart("container_memory_working_set")
			s.ContainerMemoryWorkingSet.Encode(e)
		}
	}
	{
		if s.IoReadBytes.Set {
			e.FieldStart("io_read_bytes")
			s.IoReadBytes.Encode(e)
		}
	}
	{
		if s.IoWriteBytes.Set {
			e.FieldStart("io_write_bytes")
			s.IoWriteBytes.Encode(e)
		}
	}
	{
		if s.MemoryBytes.Set {
			e.FieldStart("memory_bytes")
			s.MemoryBytes.Encode(e)
		}
	}
}

var jsonFieldsNameOfResourceUsage = [11]string{
	0:  "cpu_percent",
	1:  "memory_rss",
	2:  "memory_vms",
	3:  "open_files",
	4:  "thread_count",
	5:  "container_memory_usage",
	6:  "container_memory_limit",
	7:  "container_memory_working_set",
	8:  "io_read_bytes",
	9:  "io_write_bytes",
	10: "memory_bytes",
}

// Decode decodes ResourceUsage from json.
func (s *ResourceUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResourceUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu_percent":
			if err := func() error {
				s.CPUPercent.Reset()
				if err := s.CPUPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu_percent\"")
			}
		case "memory_rss":
			if err := func() error {
				s.MemoryRss.Reset()
				if err := s.MemoryRss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory_rss\"")
			}
		case "memory_vms":
			if err := func() error {
				s.MemoryVms.Reset()
				if err := s.MemoryVms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory_vms\"")
			}
		case "open_files":
			if err := func() error {
				s.OpenFiles.Reset()
				if err := s.OpenFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"open_files\"")
			}
		case "thread_count":
			if err := func() error {
				s.ThreadCount.Reset()
				if err := s.ThreadCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_count\"")
			}
		case "container_memory_usage":
			if err := func() error {
				s.ContainerMemoryUsage.Reset()
				if err := s.ContainerMemoryUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_memory_usage\"")
			}
		case "container_memory_limit":
			if err := func() error {
				s.ContainerMemoryLimit.Reset()
				if err := s.ContainerMemoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_memory_limit\"")
			}
		case "container_memory_working_set":
			if err := func() error {
				s.ContainerMemoryWorkingSet.Reset()
				if err := s.ContainerMemoryWorkingSet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_memory_working_set\"")
			}
		case "io_read_bytes":
			if err := func() error {
				s.IoReadBytes.Reset()
				if err := s.IoReadBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"io_read_bytes\"")
			}
		case "io_write_bytes":
			if err := func() error {
				s.IoWriteBytes.Reset()
				if err := s.IoWriteBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"io_write_bytes\"")
			}
		case "memory_bytes":
			if err := func() error {
				s.MemoryBytes.Reset()
				if err := s.MemoryBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory_bytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResourceUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResourceUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResourceUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResumeSandboxResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResumeSandboxResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandbox_id")
		e.Str(s.SandboxID)
	}
	{
		e.FieldStart("resumed")
		e.Bool(s.Resumed)
	}
	{
		if s.RestoredMemory.Set {
			e.FieldStart("restored_memory")
			s.RestoredMemory.Encode(e)
		}
	}
}

var jsonFieldsNameOfResumeSandboxResponse = [3]string{
	0: "sandbox_id",
	1: "resumed",
	2: "restored_memory",
}

// Decode decodes ResumeSandboxResponse from json.
func (s *ResumeSandboxResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResumeSandboxResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandbox_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandbox_id\"")
			}
		case "resumed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Resumed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resumed\"")
			}
		case "restored_memory":
			if err := func() error {
				s.RestoredMemory.Reset()
				if err := s.RestoredMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restored_memory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResumeSandboxResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResumeSandboxResponse) {
					name = jsonFieldsNameOfResumeSandboxResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResumeSandboxResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResumeSandboxResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Sandbox) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Sandbox) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("template_id")
		e.Str(s.TemplateID)
	}
	{
		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		e.FieldStart("status")
		e.Str(s.Status)
	}
	{
		e.FieldStart("paused")
		e.Bool(s.Paused)
	}
	{
		e.FieldStart("auto_resume")
		e.Bool(s.AutoResume)
	}
	{
		if s.ExposedPorts != nil {
			e.FieldStart("exposed_ports")
			e.ArrStart()
			for _, elem := range s.ExposedPorts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("pod_name")
		e.Str(s.PodName)
	}
	{
		e.FieldStart("expires_at")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("claimed_at")
		json.EncodeDateTime(e, s.ClaimedAt)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfSandbox = [12]string{
	0:  "id",
	1:  "template_id",
	2:  "team_id",
	3:  "user_id",
	4:  "status",
	5:  "paused",
	6:  "auto_resume",
	7:  "exposed_ports",
	8:  "pod_name",
	9:  "expires_at",
	10: "claimed_at",
	11: "created_at",
}

// Decode decodes Sandbox from json.
func (s *Sandbox) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Sandbox to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "template_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TemplateID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "paused":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.Paused = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused\"")
			}
		case "auto_resume":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AutoResume = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_resume\"")
			}
		case "exposed_ports":
			if err := func() error {
				s.ExposedPorts = make([]ExposedPortConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExposedPortConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExposedPorts = append(s.ExposedPorts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exposed_ports\"")
			}
		case "pod_name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PodName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pod_name\"")
			}
		case "expires_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "claimed_at":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ClaimedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed_at\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Sandbox")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01110111,
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSandbox) {
					name = jsonFieldsNameOfSandbox[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Sandbox) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Sandbox) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SandboxConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SandboxConfig) encodeFields(e *jx.Encoder) {
	{
		if s.EnvVars.Set {
			e.FieldStart("env_vars")
			s.EnvVars.Encode(e)
		}
	}
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		if s.HardTTL.Set {
			e.FieldStart("hard_ttl")
			s.HardTTL.Encode(e)
		}
	}
	{
		if s.Network.Set {
			e.FieldStart("network")
			s.Network.Encode(e)
		}
	}
	{
		if s.Webhook.Set {
			e.FieldStart("webhook")
			s.Webhook.Encode(e)
		}
	}
	{
		if s.AutoResume.Set {
			e.FieldStart("auto_resume")
			s.AutoResume.Encode(e)
		}
	}
	{
		if s.ExposedPorts != nil {
			e.FieldStart("exposed_ports")
			e.ArrStart()
			for _, elem := range s.ExposedPorts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSandboxConfig = [7]string{
	0: "env_vars",
	1: "ttl",
	2: "hard_ttl",
	3: "network",
	4: "webhook",
	5: "auto_resume",
	6: "exposed_ports",
}

// Decode decodes SandboxConfig from json.
func (s *SandboxConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "env_vars":
			if err := func() error {
				s.EnvVars.Reset()
				if err := s.EnvVars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env_vars\"")
			}
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "hard_ttl":
			if err := func() error {
				s.HardTTL.Reset()
				if err := s.HardTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hard_ttl\"")
			}
		case "network":
			if err := func() error {
				s.Network.Reset()
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "webhook":
			if err := func() error {
				s.Webhook.Reset()
				if err := s.Webhook.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"webhook\"")
			}
		case "auto_resume":
			if err := func() error {
				s.AutoResume.Reset()
				if err := s.AutoResume.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto_resume\"")
			}
		case "exposed_ports":
			if err := func() error {
				s.ExposedPorts = make([]ExposedPortConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExposedPortConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExposedPorts = append(s.ExposedPorts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exposed_ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SandboxConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SandboxConfigEnvVars) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SandboxConfigEnvVars) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SandboxConfigEnvVars from json.
func (s *SandboxConfigEnvVars) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxConfigEnvVars to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxConfigEnvVars")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SandboxConfigEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxConfigEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SandboxResourceUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SandboxResourceUsage) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerMemoryUsage.Set {
			e.FieldStart("container_memory_usage")
			s.ContainerMemoryUsage.Encode(e)
		}
	}
	{
		if s.ContainerMemoryLimit.Set {
			e.FieldStart("container_memory_limit")
			s.ContainerMemoryLimit.Encode(e)
		}
	}
	{
		if s.ContainerMemoryWorkingSet.Set {
			e.FieldStart("container_memory_working_set")
			s.ContainerMemoryWorkingSet.Encode(e)
		}
	}
	{
		if s.TotalMemoryRss.Set {
			e.FieldStart("total_memory_rss")
			s.TotalMemoryRss.Encode(e)
		}
	}
	{
		if s.TotalMemoryVms.Set {
			e.FieldStart("total_memory_vms")
			s.TotalMemoryVms.Encode(e)
		}
	}
	{
		if s.TotalOpenFiles.Set {
			e.FieldStart("total_open_files")
			s.TotalOpenFiles.Encode(e)
		}
	}
	{
		if s.TotalThreadCount.Set {
			e.FieldStart("total_thread_count")
			s.TotalThreadCount.Encode(e)
		}
	}
	{
		if s.TotalIoReadBytes.Set {
			e.FieldStart("total_io_read_bytes")
			s.TotalIoReadBytes.Encode(e)
		}
	}
	{
		if s.TotalIoWriteBytes.Set {
			e.FieldStart("total_io_write_bytes")
			s.TotalIoWriteBytes.Encode(e)
		}
	}
	{
		if s.ContextCount.Set {
			e.FieldStart("context_count")
			s.ContextCount.Encode(e)
		}
	}
	{
		if s.RunningContextCount.Set {
			e.FieldStart("running_context_count")
			s.RunningContextCount.Encode(e)
		}
	}
	{
		if s.PausedContextCount.Set {
			e.FieldStart("paused_context_count")
			s.PausedContextCount.Encode(e)
		}
	}
	{
		if s.Contexts != nil {
			e.FieldStart("contexts")
			e.ArrStart()
			for _, elem := range s.Contexts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSandboxResourceUsage = [13]string{
	0:  "container_memory_usage",
	1:  "container_memory_limit",
	2:  "container_memory_working_set",
	3:  "total_memory_rss",
	4:  "total_memory_vms",
	5:  "total_open_files",
	6:  "total_thread_count",
	7:  "total_io_read_bytes",
	8:  "total_io_write_bytes",
	9:  "context_count",
	10: "running_context_count",
	11: "paused_context_count",
	12: "contexts",
}

// Decode decodes SandboxResourceUsage from json.
func (s *SandboxResourceUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxResourceUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "container_memory_usage":
			if err := func() error {
				s.ContainerMemoryUsage.Reset()
				if err := s.ContainerMemoryUsage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_memory_usage\"")
			}
		case "container_memory_limit":
			if err := func() error {
				s.ContainerMemoryLimit.Reset()
				if err := s.ContainerMemoryLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_memory_limit\"")
			}
		case "container_memory_working_set":
			if err := func() error {
				s.ContainerMemoryWorkingSet.Reset()
				if err := s.ContainerMemoryWorkingSet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container_memory_working_set\"")
			}
		case "total_memory_rss":
			if err := func() error {
				s.TotalMemoryRss.Reset()
				if err := s.TotalMemoryRss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_memory_rss\"")
			}
		case "total_memory_vms":
			if err := func() error {
				s.TotalMemoryVms.Reset()
				if err := s.TotalMemoryVms.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_memory_vms\"")
			}
		case "total_open_files":
			if err := func() error {
				s.TotalOpenFiles.Reset()
				if err := s.TotalOpenFiles.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_open_files\"")
			}
		case "total_thread_count":
			if err := func() error {
				s.TotalThreadCount.Reset()
				if err := s.TotalThreadCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_thread_count\"")
			}
		case "total_io_read_bytes":
			if err := func() error {
				s.TotalIoReadBytes.Reset()
				if err := s.TotalIoReadBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_io_read_bytes\"")
			}
		case "total_io_write_bytes":
			if err := func() error {
				s.TotalIoWriteBytes.Reset()
				if err := s.TotalIoWriteBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_io_write_bytes\"")
			}
		case "context_count":
			if err := func() error {
				s.ContextCount.Reset()
				if err := s.ContextCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context_count\"")
			}
		case "running_context_count":
			if err := func() error {
				s.RunningContextCount.Reset()
				if err := s.RunningContextCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"running_context_count\"")
			}
		case "paused_context_count":
			if err := func() error {
				s.PausedContextCount.Reset()
				if err := s.PausedContextCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paused_context_count\"")
			}
		case "contexts":
			if err := func() error {
				s.Contexts = make([]ContextResourceUsage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContextResourceUsage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxResourceUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SandboxResourceUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxResourceUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SandboxStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SandboxStatus) encodeFields(e *jx.Encoder) {
	{
		if s.SandboxID.Set {
			e.FieldStart("sandbox_id")
			s.SandboxID.Encode(e)
		}
	}
	{
		if s.TemplateID.Set {
			e.FieldStart("template_id")
			s.TemplateID.Encode(e)
		}
	}
	{
		if s.TeamID.Set {
			e.FieldStart("team_id")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		if s.PodName.Set {
			e.FieldStart("pod_name")
			s.PodName.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ClaimedAt.Set {
			e.FieldStart("claimed_at")
			s.ClaimedAt.Encode(e)
		}
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("created_at")
			s.CreatedAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfSandboxStatus = [9]string{
	0: "sandbox_id",
	1: "template_id",
	2: "team_id",
	3: "user_id",
	4: "pod_name",
	5: "status",
	6: "claimed_at",
	7: "expires_at",
	8: "created_at",
}

// Decode decodes SandboxStatus from json.
func (s *SandboxStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandbox_id":
			if err := func() error {
				s.SandboxID.Reset()
				if err := s.SandboxID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandbox_id\"")
			}
		case "template_id":
			if err := func() error {
				s.TemplateID.Reset()
				if err := s.TemplateID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		case "team_id":
			if err := func() error {
				s.TeamID.Reset()
				if err := s.TeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "pod_name":
			if err := func() error {
				s.PodName.Reset()
				if err := s.PodName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pod_name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "claimed_at":
			if err := func() error {
				s.ClaimedAt.Reset()
				if err := s.ClaimedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claimed_at\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		case "created_at":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SandboxStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SandboxTemplateSpec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SandboxTemplateSpec) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DisplayName.Set {
			e.FieldStart("displayName")
			s.DisplayName.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MainContainer.Set {
			e.FieldStart("mainContainer")
			s.MainContainer.Encode(e)
		}
	}
	{
		if s.Sidecars != nil {
			e.FieldStart("sidecars")
			e.ArrStart()
			for _, elem := range s.Sidecars {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Pod.Set {
			e.FieldStart("pod")
			s.Pod.Encode(e)
		}
	}
	{
		if s.Network.Set {
			e.FieldStart("network")
			s.Network.Encode(e)
		}
	}
	{
		if s.Pool.Set {
			e.FieldStart("pool")
			s.Pool.Encode(e)
		}
	}
	{
		if s.Lifecycle.Set {
			e.FieldStart("lifecycle")
			s.Lifecycle.Encode(e)
		}
	}
	{
		if s.EnvVars.Set {
			e.FieldStart("envVars")
			s.EnvVars.Encode(e)
		}
	}
	{
		if s.Public.Set {
			e.FieldStart("public")
			s.Public.Encode(e)
		}
	}
	{
		if s.AllowedTeams != nil {
			e.FieldStart("allowedTeams")
			e.ArrStart()
			for _, elem := range s.AllowedTeams {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RuntimeClassName.Set {
			e.FieldStart("runtimeClassName")
			s.RuntimeClassName.Encode(e)
		}
	}
	{
		if s.ClusterId.Set {
			e.FieldStart("clusterId")
			s.ClusterId.Encode(e)
		}
	}
}

var jsonFieldsNameOfSandboxTemplateSpec = [14]string{
	0:  "description",
	1:  "displayName",
	2:  "tags",
	3:  "mainContainer",
	4:  "sidecars",
	5:  "pod",
	6:  "network",
	7:  "pool",
	8:  "lifecycle",
	9:  "envVars",
	10: "public",
	11: "allowedTeams",
	12: "runtimeClassName",
	13: "clusterId",
}

// Decode decodes SandboxTemplateSpec from json.
func (s *SandboxTemplateSpec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxTemplateSpec to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "displayName":
			if err := func() error {
				s.DisplayName.Reset()
				if err := s.DisplayName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"displayName\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "mainContainer":
			if err := func() error {
				s.MainContainer.Reset()
				if err := s.MainContainer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mainContainer\"")
			}
		case "sidecars":
			if err := func() error {
				s.Sidecars = make([]ContainerSpec, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContainerSpec
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Sidecars = append(s.Sidecars, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sidecars\"")
			}
		case "pod":
			if err := func() error {
				s.Pod.Reset()
				if err := s.Pod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pod\"")
			}
		case "network":
			if err := func() error {
				s.Network.Reset()
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "pool":
			if err := func() error {
				s.Pool.Reset()
				if err := s.Pool.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pool\"")
			}
		case "lifecycle":
			if err := func() error {
				s.Lifecycle.Reset()
				if err := s.Lifecycle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycle\"")
			}
		case "envVars":
			if err := func() error {
				s.EnvVars.Reset()
				if err := s.EnvVars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"envVars\"")
			}
		case "public":
			if err := func() error {
				s.Public.Reset()
				if err := s.Public.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public\"")
			}
		case "allowedTeams":
			if err := func() error {
				s.AllowedTeams = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedTeams = append(s.AllowedTeams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedTeams\"")
			}
		case "runtimeClassName":
			if err := func() error {
				s.RuntimeClassName.Reset()
				if err := s.RuntimeClassName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runtimeClassName\"")
			}
		case "clusterId":
			if err := func() error {
				s.ClusterId.Reset()
				if err := s.ClusterId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxTemplateSpec")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SandboxTemplateSpec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxTemplateSpec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SandboxTemplateSpecEnvVars) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SandboxTemplateSpecEnvVars) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SandboxTemplateSpecEnvVars from json.
func (s *SandboxTemplateSpecEnvVars) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxTemplateSpecEnvVars to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxTemplateSpecEnvVars")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SandboxTemplateSpecEnvVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxTemplateSpecEnvVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SandboxUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SandboxUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
}

var jsonFieldsNameOfSandboxUpdateRequest = [1]string{
	0: "config",
}

// Decode decodes SandboxUpdateRequest from json.
func (s *SandboxUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxUpdateRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxUpdateRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SandboxUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SandboxVolume) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SandboxVolume) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
	{
		e.FieldStart("cache_size")
		e.Str(s.CacheSize)
	}
	{
		if s.Prefetch.Set {
			e.FieldStart("prefetch")
			s.Prefetch.Encode(e)
		}
	}
	{
		e.FieldStart("buffer_size")
		e.Str(s.BufferSize)
	}
	{
		if s.Writeback.Set {
			e.FieldStart("writeback")
			s.Writeback.Encode(e)
		}
	}
	{
		if s.AccessMode.Set {
			e.FieldStart("access_mode")
			s.AccessMode.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfSandboxVolume = [10]string{
	0: "id",
	1: "team_id",
	2: "user_id",
	3: "cache_size",
	4: "prefetch",
	5: "buffer_size",
	6: "writeback",
	7: "access_mode",
	8: "created_at",
	9: "updated_at",
}

// Decode decodes SandboxVolume from json.
func (s *SandboxVolume) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SandboxVolume to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "cache_size":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CacheSize = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_size\"")
			}
		case "prefetch":
			if err := func() error {
				s.Prefetch.Reset()
				if err := s.Prefetch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefetch\"")
			}
		case "buffer_size":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.BufferSize = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buffer_size\"")
			}
		case "writeback":
			if err := func() error {
				s.Writeback.Reset()
				if err := s.Writeback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeback\"")
			}
		case "access_mode":
			if err := func() error {
				s.AccessMode.Reset()
				if err := s.AccessMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_mode\"")
			}
		case "created_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SandboxVolume")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00101111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSandboxVolume) {
					name = jsonFieldsNameOfSandboxVolume[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SandboxVolume) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SandboxVolume) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecurityContext) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecurityContext) encodeFields(e *jx.Encoder) {
	{
		if s.Capabilities.Set {
			e.FieldStart("capabilities")
			s.Capabilities.Encode(e)
		}
	}
	{
		if s.RunAsUser.Set {
			e.FieldStart("runAsUser")
			s.RunAsUser.Encode(e)
		}
	}
	{
		if s.RunAsGroup.Set {
			e.FieldStart("runAsGroup")
			s.RunAsGroup.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecurityContext = [3]string{
	0: "capabilities",
	1: "runAsUser",
	2: "runAsGroup",
}

// Decode decodes SecurityContext from json.
func (s *SecurityContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecurityContext to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capabilities":
			if err := func() error {
				s.Capabilities.Reset()
				if err := s.Capabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capabilities\"")
			}
		case "runAsUser":
			if err := func() error {
				s.RunAsUser.Reset()
				if err := s.RunAsUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsUser\"")
			}
		case "runAsGroup":
			if err := func() error {
				s.RunAsGroup.Reset()
				if err := s.RunAsGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"runAsGroup\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecurityContext")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecurityContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecurityContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SignalContextRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SignalContextRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("signal")
		e.Str(s.Signal)
	}
}

var jsonFieldsNameOfSignalContextRequest = [1]string{
	0: "signal",
}

// Decode decodes SignalContextRequest from json.
func (s *SignalContextRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SignalContextRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "signal":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Signal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SignalContextRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSignalContextRequest) {
					name = jsonFieldsNameOfSignalContextRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SignalContextRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SignalContextRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Snapshot) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Snapshot) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("volume_id")
		e.Str(s.VolumeID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("size_bytes")
		e.Int64(s.SizeBytes)
	}
	{
		e.FieldStart("created_at")
		e.Str(s.CreatedAt)
	}
	{
		if s.ExpiresAt.Set {
			e.FieldStart("expires_at")
			s.ExpiresAt.Encode(e)
		}
	}
}

var jsonFieldsNameOfSnapshot = [7]string{
	0: "id",
	1: "volume_id",
	2: "name",
	3: "description",
	4: "size_bytes",
	5: "created_at",
	6: "expires_at",
}

// Decode decodes Snapshot from json.
func (s *Snapshot) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Snapshot to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "volume_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"volume_id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "size_bytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int64()
				s.SizeBytes = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size_bytes\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreatedAt = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "expires_at":
			if err := func() error {
				s.ExpiresAt.Reset()
				if err := s.ExpiresAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Snapshot")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSnapshot) {
					name = jsonFieldsNameOfSnapshot[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Snapshot) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Snapshot) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessAPIKeyListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessAPIKeyListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessAPIKeyListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessAPIKeyListResponse from json.
func (s *SuccessAPIKeyListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessAPIKeyListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessAPIKeyListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessAPIKeyListResponse) {
					name = jsonFieldsNameOfSuccessAPIKeyListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessAPIKeyListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessAPIKeyListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessAPIKeyListResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessAPIKeyListResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.APIKeys != nil {
			e.FieldStart("api_keys")
			e.ArrStart()
			for _, elem := range s.APIKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessAPIKeyListResponseData = [1]string{
	0: "api_keys",
}

// Decode decodes SuccessAPIKeyListResponseData from json.
func (s *SuccessAPIKeyListResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessAPIKeyListResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "api_keys":
			if err := func() error {
				s.APIKeys = make([]APIKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.APIKeys = append(s.APIKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api_keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessAPIKeyListResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessAPIKeyListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessAPIKeyListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessAPIKeyListResponseSuccess as json.
func (s SuccessAPIKeyListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessAPIKeyListResponseSuccess from json.
func (s *SuccessAPIKeyListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessAPIKeyListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessAPIKeyListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessAPIKeyListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessAPIKeyListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessAuthProvidersResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessAuthProvidersResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessAuthProvidersResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessAuthProvidersResponse from json.
func (s *SuccessAuthProvidersResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessAuthProvidersResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessAuthProvidersResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessAuthProvidersResponse) {
					name = jsonFieldsNameOfSuccessAuthProvidersResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessAuthProvidersResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessAuthProvidersResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessAuthProvidersResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessAuthProvidersResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Providers != nil {
			e.FieldStart("providers")
			e.ArrStart()
			for _, elem := range s.Providers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessAuthProvidersResponseData = [1]string{
	0: "providers",
}

// Decode decodes SuccessAuthProvidersResponseData from json.
func (s *SuccessAuthProvidersResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessAuthProvidersResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providers":
			if err := func() error {
				s.Providers = make([]AuthProvider, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthProvider
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Providers = append(s.Providers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessAuthProvidersResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessAuthProvidersResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessAuthProvidersResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessAuthProvidersResponseSuccess as json.
func (s SuccessAuthProvidersResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessAuthProvidersResponseSuccess from json.
func (s *SuccessAuthProvidersResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessAuthProvidersResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessAuthProvidersResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessAuthProvidersResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessAuthProvidersResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessClaimResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessClaimResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessClaimResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessClaimResponse from json.
func (s *SuccessClaimResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessClaimResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessClaimResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessClaimResponse) {
					name = jsonFieldsNameOfSuccessClaimResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessClaimResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessClaimResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessClaimResponseSuccess as json.
func (s SuccessClaimResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessClaimResponseSuccess from json.
func (s *SuccessClaimResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessClaimResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessClaimResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessClaimResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessClaimResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessContextExecResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessContextExecResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessContextExecResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessContextExecResponse from json.
func (s *SuccessContextExecResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextExecResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessContextExecResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessContextExecResponse) {
					name = jsonFieldsNameOfSuccessContextExecResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessContextExecResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextExecResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessContextExecResponseSuccess as json.
func (s SuccessContextExecResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessContextExecResponseSuccess from json.
func (s *SuccessContextExecResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextExecResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessContextExecResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessContextExecResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextExecResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessContextListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessContextListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessContextListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessContextListResponse from json.
func (s *SuccessContextListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessContextListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessContextListResponse) {
					name = jsonFieldsNameOfSuccessContextListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessContextListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessContextListResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessContextListResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Contexts != nil {
			e.FieldStart("contexts")
			e.ArrStart()
			for _, elem := range s.Contexts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessContextListResponseData = [1]string{
	0: "contexts",
}

// Decode decodes SuccessContextListResponseData from json.
func (s *SuccessContextListResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextListResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contexts":
			if err := func() error {
				s.Contexts = make([]ContextResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContextResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Contexts = append(s.Contexts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessContextListResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessContextListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessContextListResponseSuccess as json.
func (s SuccessContextListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessContextListResponseSuccess from json.
func (s *SuccessContextListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessContextListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessContextListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessContextResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessContextResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessContextResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessContextResponse from json.
func (s *SuccessContextResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessContextResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessContextResponse) {
					name = jsonFieldsNameOfSuccessContextResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessContextResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessContextResponseSuccess as json.
func (s SuccessContextResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessContextResponseSuccess from json.
func (s *SuccessContextResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessContextResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessContextResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessContextStatsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessContextStatsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessContextStatsResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessContextStatsResponse from json.
func (s *SuccessContextStatsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextStatsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessContextStatsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessContextStatsResponse) {
					name = jsonFieldsNameOfSuccessContextStatsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessContextStatsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextStatsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessContextStatsResponseSuccess as json.
func (s SuccessContextStatsResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessContextStatsResponseSuccess from json.
func (s *SuccessContextStatsResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessContextStatsResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessContextStatsResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessContextStatsResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessContextStatsResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessCreateAPIKeyResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessCreateAPIKeyResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessCreateAPIKeyResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessCreateAPIKeyResponse from json.
func (s *SuccessCreateAPIKeyResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessCreateAPIKeyResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessCreateAPIKeyResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessCreateAPIKeyResponse) {
					name = jsonFieldsNameOfSuccessCreateAPIKeyResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessCreateAPIKeyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessCreateAPIKeyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessCreateAPIKeyResponseSuccess as json.
func (s SuccessCreateAPIKeyResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessCreateAPIKeyResponseSuccess from json.
func (s *SuccessCreateAPIKeyResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessCreateAPIKeyResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessCreateAPIKeyResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessCreateAPIKeyResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessCreateAPIKeyResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessCreatedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessCreatedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessCreatedResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessCreatedResponse from json.
func (s *SuccessCreatedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessCreatedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessCreatedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessCreatedResponse) {
					name = jsonFieldsNameOfSuccessCreatedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessCreatedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessCreatedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessCreatedResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessCreatedResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Created.Set {
			e.FieldStart("created")
			s.Created.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessCreatedResponseData = [1]string{
	0: "created",
}

// Decode decodes SuccessCreatedResponseData from json.
func (s *SuccessCreatedResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessCreatedResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessCreatedResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessCreatedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessCreatedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessCreatedResponseSuccess as json.
func (s SuccessCreatedResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessCreatedResponseSuccess from json.
func (s *SuccessCreatedResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessCreatedResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessCreatedResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessCreatedResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessCreatedResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessDeletedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessDeletedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessDeletedResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessDeletedResponse from json.
func (s *SuccessDeletedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessDeletedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessDeletedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessDeletedResponse) {
					name = jsonFieldsNameOfSuccessDeletedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessDeletedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessDeletedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessDeletedResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessDeletedResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Deleted.Set {
			e.FieldStart("deleted")
			s.Deleted.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessDeletedResponseData = [1]string{
	0: "deleted",
}

// Decode decodes SuccessDeletedResponseData from json.
func (s *SuccessDeletedResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessDeletedResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deleted":
			if err := func() error {
				s.Deleted.Reset()
				if err := s.Deleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessDeletedResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessDeletedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessDeletedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessDeletedResponseSuccess as json.
func (s SuccessDeletedResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessDeletedResponseSuccess from json.
func (s *SuccessDeletedResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessDeletedResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessDeletedResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessDeletedResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessDeletedResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessExposedPortsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessExposedPortsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessExposedPortsResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessExposedPortsResponse from json.
func (s *SuccessExposedPortsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessExposedPortsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessExposedPortsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessExposedPortsResponse) {
					name = jsonFieldsNameOfSuccessExposedPortsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessExposedPortsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessExposedPortsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessExposedPortsResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessExposedPortsResponseData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandbox_id")
		e.Str(s.SandboxID)
	}
	{
		e.FieldStart("exposed_ports")
		e.ArrStart()
		for _, elem := range s.ExposedPorts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.ExposureDomain.Set {
			e.FieldStart("exposure_domain")
			s.ExposureDomain.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessExposedPortsResponseData = [3]string{
	0: "sandbox_id",
	1: "exposed_ports",
	2: "exposure_domain",
}

// Decode decodes SuccessExposedPortsResponseData from json.
func (s *SuccessExposedPortsResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessExposedPortsResponseData to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandbox_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandbox_id\"")
			}
		case "exposed_ports":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ExposedPorts = make([]ExposedPortConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExposedPortConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExposedPorts = append(s.ExposedPorts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exposed_ports\"")
			}
		case "exposure_domain":
			if err := func() error {
				s.ExposureDomain.Reset()
				if err := s.ExposureDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exposure_domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessExposedPortsResponseData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessExposedPortsResponseData) {
					name = jsonFieldsNameOfSuccessExposedPortsResponseData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessExposedPortsResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessExposedPortsResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessExposedPortsResponseSuccess as json.
func (s SuccessExposedPortsResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessExposedPortsResponseSuccess from json.
func (s *SuccessExposedPortsResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessExposedPortsResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessExposedPortsResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessExposedPortsResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessExposedPortsResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessFileListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessFileListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessFileListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessFileListResponse from json.
func (s *SuccessFileListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessFileListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessFileListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessFileListResponse) {
					name = jsonFieldsNameOfSuccessFileListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessFileListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessFileListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessFileListResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessFileListResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Entries != nil {
			e.FieldStart("entries")
			e.ArrStart()
			for _, elem := range s.Entries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessFileListResponseData = [1]string{
	0: "entries",
}

// Decode decodes SuccessFileListResponseData from json.
func (s *SuccessFileListResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessFileListResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "entries":
			if err := func() error {
				s.Entries = make([]FileInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FileInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Entries = append(s.Entries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"entries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessFileListResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessFileListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessFileListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessFileListResponseSuccess as json.
func (s SuccessFileListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessFileListResponseSuccess from json.
func (s *SuccessFileListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessFileListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessFileListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessFileListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessFileListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessFileStatResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessFileStatResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessFileStatResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessFileStatResponse from json.
func (s *SuccessFileStatResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessFileStatResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessFileStatResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessFileStatResponse) {
					name = jsonFieldsNameOfSuccessFileStatResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessFileStatResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessFileStatResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessFileStatResponseSuccess as json.
func (s SuccessFileStatResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessFileStatResponseSuccess from json.
func (s *SuccessFileStatResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessFileStatResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessFileStatResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessFileStatResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessFileStatResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessHealthResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessHealthResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessHealthResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessHealthResponse from json.
func (s *SuccessHealthResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessHealthResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessHealthResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessHealthResponse) {
					name = jsonFieldsNameOfSuccessHealthResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessHealthResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessHealthResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessHealthResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessHealthResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessHealthResponseData = [2]string{
	0: "status",
	1: "timestamp",
}

// Decode decodes SuccessHealthResponseData from json.
func (s *SuccessHealthResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessHealthResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessHealthResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessHealthResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessHealthResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessHealthResponseSuccess as json.
func (s SuccessHealthResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessHealthResponseSuccess from json.
func (s *SuccessHealthResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessHealthResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessHealthResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessHealthResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessHealthResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessIdentityListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessIdentityListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessIdentityListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessIdentityListResponse from json.
func (s *SuccessIdentityListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessIdentityListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessIdentityListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessIdentityListResponse) {
					name = jsonFieldsNameOfSuccessIdentityListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessIdentityListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessIdentityListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessIdentityListResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessIdentityListResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Identities != nil {
			e.FieldStart("identities")
			e.ArrStart()
			for _, elem := range s.Identities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessIdentityListResponseData = [1]string{
	0: "identities",
}

// Decode decodes SuccessIdentityListResponseData from json.
func (s *SuccessIdentityListResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessIdentityListResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "identities":
			if err := func() error {
				s.Identities = make([]Identity, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Identity
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Identities = append(s.Identities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"identities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessIdentityListResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessIdentityListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessIdentityListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessIdentityListResponseSuccess as json.
func (s SuccessIdentityListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessIdentityListResponseSuccess from json.
func (s *SuccessIdentityListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessIdentityListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessIdentityListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessIdentityListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessIdentityListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessLoginResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessLoginResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessLoginResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessLoginResponse from json.
func (s *SuccessLoginResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessLoginResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessLoginResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessLoginResponse) {
					name = jsonFieldsNameOfSuccessLoginResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessLoginResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessLoginResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessLoginResponseSuccess as json.
func (s SuccessLoginResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessLoginResponseSuccess from json.
func (s *SuccessLoginResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessLoginResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessLoginResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessLoginResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessLoginResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessMessageResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessMessageResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessMessageResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessMessageResponse from json.
func (s *SuccessMessageResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMessageResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessMessageResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessMessageResponse) {
					name = jsonFieldsNameOfSuccessMessageResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessMessageResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMessageResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessMessageResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessMessageResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessMessageResponseData = [1]string{
	0: "message",
}

// Decode decodes SuccessMessageResponseData from json.
func (s *SuccessMessageResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMessageResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessMessageResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessMessageResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMessageResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessMessageResponseSuccess as json.
func (s SuccessMessageResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessMessageResponseSuccess from json.
func (s *SuccessMessageResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMessageResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessMessageResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessMessageResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMessageResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessMountResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessMountResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessMountResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessMountResponse from json.
func (s *SuccessMountResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMountResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessMountResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessMountResponse) {
					name = jsonFieldsNameOfSuccessMountResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessMountResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMountResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessMountResponseSuccess as json.
func (s SuccessMountResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessMountResponseSuccess from json.
func (s *SuccessMountResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMountResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessMountResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessMountResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMountResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessMountStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessMountStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessMountStatusResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessMountStatusResponse from json.
func (s *SuccessMountStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMountStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessMountStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessMountStatusResponse) {
					name = jsonFieldsNameOfSuccessMountStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessMountStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMountStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessMountStatusResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessMountStatusResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Mounts != nil {
			e.FieldStart("mounts")
			e.ArrStart()
			for _, elem := range s.Mounts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessMountStatusResponseData = [1]string{
	0: "mounts",
}

// Decode decodes SuccessMountStatusResponseData from json.
func (s *SuccessMountStatusResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMountStatusResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mounts":
			if err := func() error {
				s.Mounts = make([]MountStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MountStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Mounts = append(s.Mounts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mounts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessMountStatusResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessMountStatusResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMountStatusResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessMountStatusResponseSuccess as json.
func (s SuccessMountStatusResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessMountStatusResponseSuccess from json.
func (s *SuccessMountStatusResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMountStatusResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessMountStatusResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessMountStatusResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMountStatusResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessMovedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessMovedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessMovedResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessMovedResponse from json.
func (s *SuccessMovedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMovedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessMovedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessMovedResponse) {
					name = jsonFieldsNameOfSuccessMovedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessMovedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMovedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessMovedResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessMovedResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Moved.Set {
			e.FieldStart("moved")
			s.Moved.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessMovedResponseData = [1]string{
	0: "moved",
}

// Decode decodes SuccessMovedResponseData from json.
func (s *SuccessMovedResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMovedResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "moved":
			if err := func() error {
				s.Moved.Reset()
				if err := s.Moved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moved\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessMovedResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessMovedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMovedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessMovedResponseSuccess as json.
func (s SuccessMovedResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessMovedResponseSuccess from json.
func (s *SuccessMovedResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessMovedResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessMovedResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessMovedResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessMovedResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessPauseSandboxResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessPauseSandboxResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessPauseSandboxResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessPauseSandboxResponse from json.
func (s *SuccessPauseSandboxResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessPauseSandboxResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessPauseSandboxResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessPauseSandboxResponse) {
					name = jsonFieldsNameOfSuccessPauseSandboxResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessPauseSandboxResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessPauseSandboxResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessPauseSandboxResponseSuccess as json.
func (s SuccessPauseSandboxResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessPauseSandboxResponseSuccess from json.
func (s *SuccessPauseSandboxResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessPauseSandboxResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessPauseSandboxResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessPauseSandboxResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessPauseSandboxResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessRefreshResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessRefreshResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessRefreshResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessRefreshResponse from json.
func (s *SuccessRefreshResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessRefreshResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessRefreshResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessRefreshResponse) {
					name = jsonFieldsNameOfSuccessRefreshResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessRefreshResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessRefreshResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessRefreshResponseSuccess as json.
func (s SuccessRefreshResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessRefreshResponseSuccess from json.
func (s *SuccessRefreshResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessRefreshResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessRefreshResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessRefreshResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessRefreshResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessRegistryCredentialsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessRegistryCredentialsResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessRegistryCredentialsResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessRegistryCredentialsResponse from json.
func (s *SuccessRegistryCredentialsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessRegistryCredentialsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessRegistryCredentialsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessRegistryCredentialsResponse) {
					name = jsonFieldsNameOfSuccessRegistryCredentialsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessRegistryCredentialsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessRegistryCredentialsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessRegistryCredentialsResponseSuccess as json.
func (s SuccessRegistryCredentialsResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessRegistryCredentialsResponseSuccess from json.
func (s *SuccessRegistryCredentialsResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessRegistryCredentialsResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessRegistryCredentialsResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessRegistryCredentialsResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessRegistryCredentialsResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResizedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResizedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessResizedResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessResizedResponse from json.
func (s *SuccessResizedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResizedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResizedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessResizedResponse) {
					name = jsonFieldsNameOfSuccessResizedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResizedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResizedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResizedResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResizedResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Resized.Set {
			e.FieldStart("resized")
			s.Resized.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessResizedResponseData = [1]string{
	0: "resized",
}

// Decode decodes SuccessResizedResponseData from json.
func (s *SuccessResizedResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResizedResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resized":
			if err := func() error {
				s.Resized.Reset()
				if err := s.Resized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resized\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResizedResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResizedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResizedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessResizedResponseSuccess as json.
func (s SuccessResizedResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessResizedResponseSuccess from json.
func (s *SuccessResizedResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResizedResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessResizedResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessResizedResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResizedResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessRestoreResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessRestoreResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessRestoreResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessRestoreResponse from json.
func (s *SuccessRestoreResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessRestoreResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessRestoreResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessRestoreResponse) {
					name = jsonFieldsNameOfSuccessRestoreResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessRestoreResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessRestoreResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessRestoreResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessRestoreResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessRestoreResponseData = [1]string{
	0: "status",
}

// Decode decodes SuccessRestoreResponseData from json.
func (s *SuccessRestoreResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessRestoreResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessRestoreResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessRestoreResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessRestoreResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessRestoreResponseSuccess as json.
func (s SuccessRestoreResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessRestoreResponseSuccess from json.
func (s *SuccessRestoreResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessRestoreResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessRestoreResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessRestoreResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessRestoreResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessResumeSandboxResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessResumeSandboxResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessResumeSandboxResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessResumeSandboxResponse from json.
func (s *SuccessResumeSandboxResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResumeSandboxResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessResumeSandboxResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessResumeSandboxResponse) {
					name = jsonFieldsNameOfSuccessResumeSandboxResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessResumeSandboxResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResumeSandboxResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessResumeSandboxResponseSuccess as json.
func (s SuccessResumeSandboxResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessResumeSandboxResponseSuccess from json.
func (s *SuccessResumeSandboxResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessResumeSandboxResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessResumeSandboxResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessResumeSandboxResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessResumeSandboxResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSandboxNetworkPolicyResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSandboxNetworkPolicyResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessSandboxNetworkPolicyResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSandboxNetworkPolicyResponse from json.
func (s *SuccessSandboxNetworkPolicyResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxNetworkPolicyResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSandboxNetworkPolicyResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSandboxNetworkPolicyResponse) {
					name = jsonFieldsNameOfSuccessSandboxNetworkPolicyResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSandboxNetworkPolicyResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxNetworkPolicyResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSandboxNetworkPolicyResponseSuccess as json.
func (s SuccessSandboxNetworkPolicyResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSandboxNetworkPolicyResponseSuccess from json.
func (s *SuccessSandboxNetworkPolicyResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxNetworkPolicyResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSandboxNetworkPolicyResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSandboxNetworkPolicyResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxNetworkPolicyResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSandboxResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSandboxResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessSandboxResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSandboxResponse from json.
func (s *SuccessSandboxResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSandboxResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSandboxResponse) {
					name = jsonFieldsNameOfSuccessSandboxResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSandboxResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSandboxResponseSuccess as json.
func (s SuccessSandboxResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSandboxResponseSuccess from json.
func (s *SuccessSandboxResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSandboxResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSandboxResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSandboxStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSandboxStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessSandboxStatusResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSandboxStatusResponse from json.
func (s *SuccessSandboxStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSandboxStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSandboxStatusResponse) {
					name = jsonFieldsNameOfSuccessSandboxStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSandboxStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSandboxStatusResponseSuccess as json.
func (s SuccessSandboxStatusResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSandboxStatusResponseSuccess from json.
func (s *SuccessSandboxStatusResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxStatusResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSandboxStatusResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSandboxStatusResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxStatusResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSandboxVolumeListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSandboxVolumeListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessSandboxVolumeListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSandboxVolumeListResponse from json.
func (s *SuccessSandboxVolumeListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxVolumeListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]SandboxVolume, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SandboxVolume
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSandboxVolumeListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSandboxVolumeListResponse) {
					name = jsonFieldsNameOfSuccessSandboxVolumeListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSandboxVolumeListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxVolumeListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSandboxVolumeListResponseSuccess as json.
func (s SuccessSandboxVolumeListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSandboxVolumeListResponseSuccess from json.
func (s *SuccessSandboxVolumeListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxVolumeListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSandboxVolumeListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSandboxVolumeListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxVolumeListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSandboxVolumeResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSandboxVolumeResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessSandboxVolumeResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSandboxVolumeResponse from json.
func (s *SuccessSandboxVolumeResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxVolumeResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSandboxVolumeResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSandboxVolumeResponse) {
					name = jsonFieldsNameOfSuccessSandboxVolumeResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSandboxVolumeResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxVolumeResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSandboxVolumeResponseSuccess as json.
func (s SuccessSandboxVolumeResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSandboxVolumeResponseSuccess from json.
func (s *SuccessSandboxVolumeResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSandboxVolumeResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSandboxVolumeResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSandboxVolumeResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSandboxVolumeResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSignaledResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSignaledResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessSignaledResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSignaledResponse from json.
func (s *SuccessSignaledResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSignaledResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSignaledResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSignaledResponse) {
					name = jsonFieldsNameOfSuccessSignaledResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSignaledResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSignaledResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSignaledResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSignaledResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Signaled.Set {
			e.FieldStart("signaled")
			s.Signaled.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessSignaledResponseData = [1]string{
	0: "signaled",
}

// Decode decodes SuccessSignaledResponseData from json.
func (s *SuccessSignaledResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSignaledResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "signaled":
			if err := func() error {
				s.Signaled.Reset()
				if err := s.Signaled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signaled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSignaledResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSignaledResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSignaledResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSignaledResponseSuccess as json.
func (s SuccessSignaledResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSignaledResponseSuccess from json.
func (s *SuccessSignaledResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSignaledResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSignaledResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSignaledResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSignaledResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSnapshotListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSnapshotListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data != nil {
			e.FieldStart("data")
			e.ArrStart()
			for _, elem := range s.Data {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessSnapshotListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSnapshotListResponse from json.
func (s *SuccessSnapshotListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSnapshotListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data = make([]Snapshot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Snapshot
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Data = append(s.Data, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSnapshotListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSnapshotListResponse) {
					name = jsonFieldsNameOfSuccessSnapshotListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSnapshotListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSnapshotListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSnapshotListResponseSuccess as json.
func (s SuccessSnapshotListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSnapshotListResponseSuccess from json.
func (s *SuccessSnapshotListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSnapshotListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSnapshotListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSnapshotListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSnapshotListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessSnapshotResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessSnapshotResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessSnapshotResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessSnapshotResponse from json.
func (s *SuccessSnapshotResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSnapshotResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessSnapshotResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessSnapshotResponse) {
					name = jsonFieldsNameOfSuccessSnapshotResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessSnapshotResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSnapshotResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessSnapshotResponseSuccess as json.
func (s SuccessSnapshotResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessSnapshotResponseSuccess from json.
func (s *SuccessSnapshotResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessSnapshotResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessSnapshotResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessSnapshotResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessSnapshotResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTeamListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTeamListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessTeamListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessTeamListResponse from json.
func (s *SuccessTeamListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTeamListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessTeamListResponse) {
					name = jsonFieldsNameOfSuccessTeamListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTeamListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTeamListResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTeamListResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Teams != nil {
			e.FieldStart("teams")
			e.ArrStart()
			for _, elem := range s.Teams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessTeamListResponseData = [1]string{
	0: "teams",
}

// Decode decodes SuccessTeamListResponseData from json.
func (s *SuccessTeamListResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamListResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "teams":
			if err := func() error {
				s.Teams = make([]Team, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Team
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Teams = append(s.Teams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"teams\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTeamListResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTeamListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTeamListResponseSuccess as json.
func (s SuccessTeamListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessTeamListResponseSuccess from json.
func (s *SuccessTeamListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessTeamListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessTeamListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTeamMemberListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTeamMemberListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessTeamMemberListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessTeamMemberListResponse from json.
func (s *SuccessTeamMemberListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamMemberListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTeamMemberListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessTeamMemberListResponse) {
					name = jsonFieldsNameOfSuccessTeamMemberListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTeamMemberListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamMemberListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTeamMemberListResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTeamMemberListResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Members != nil {
			e.FieldStart("members")
			e.ArrStart()
			for _, elem := range s.Members {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSuccessTeamMemberListResponseData = [1]string{
	0: "members",
}

// Decode decodes SuccessTeamMemberListResponseData from json.
func (s *SuccessTeamMemberListResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamMemberListResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "members":
			if err := func() error {
				s.Members = make([]TeamMember, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TeamMember
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTeamMemberListResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTeamMemberListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamMemberListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTeamMemberListResponseSuccess as json.
func (s SuccessTeamMemberListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessTeamMemberListResponseSuccess from json.
func (s *SuccessTeamMemberListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamMemberListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessTeamMemberListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessTeamMemberListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamMemberListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTeamMemberResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTeamMemberResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessTeamMemberResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessTeamMemberResponse from json.
func (s *SuccessTeamMemberResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamMemberResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTeamMemberResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessTeamMemberResponse) {
					name = jsonFieldsNameOfSuccessTeamMemberResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTeamMemberResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamMemberResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTeamMemberResponseSuccess as json.
func (s SuccessTeamMemberResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessTeamMemberResponseSuccess from json.
func (s *SuccessTeamMemberResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamMemberResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessTeamMemberResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessTeamMemberResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamMemberResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTeamResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTeamResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessTeamResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessTeamResponse from json.
func (s *SuccessTeamResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTeamResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessTeamResponse) {
					name = jsonFieldsNameOfSuccessTeamResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTeamResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTeamResponseSuccess as json.
func (s SuccessTeamResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessTeamResponseSuccess from json.
func (s *SuccessTeamResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTeamResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessTeamResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessTeamResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTeamResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTemplateListResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTemplateListResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessTemplateListResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessTemplateListResponse from json.
func (s *SuccessTemplateListResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTemplateListResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTemplateListResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessTemplateListResponse) {
					name = jsonFieldsNameOfSuccessTemplateListResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTemplateListResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTemplateListResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTemplateListResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTemplateListResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Templates != nil {
			e.FieldStart("templates")
			e.ArrStart()
			for _, elem := range s.Templates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessTemplateListResponseData = [2]string{
	0: "templates",
	1: "count",
}

// Decode decodes SuccessTemplateListResponseData from json.
func (s *SuccessTemplateListResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTemplateListResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templates":
			if err := func() error {
				s.Templates = make([]Template, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Template
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTemplateListResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTemplateListResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTemplateListResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTemplateListResponseSuccess as json.
func (s SuccessTemplateListResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessTemplateListResponseSuccess from json.
func (s *SuccessTemplateListResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTemplateListResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessTemplateListResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessTemplateListResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTemplateListResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessTemplateResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessTemplateResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessTemplateResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessTemplateResponse from json.
func (s *SuccessTemplateResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTemplateResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessTemplateResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessTemplateResponse) {
					name = jsonFieldsNameOfSuccessTemplateResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessTemplateResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTemplateResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessTemplateResponseSuccess as json.
func (s SuccessTemplateResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessTemplateResponseSuccess from json.
func (s *SuccessTemplateResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessTemplateResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessTemplateResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessTemplateResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessTemplateResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessUnmountedResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessUnmountedResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessUnmountedResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessUnmountedResponse from json.
func (s *SuccessUnmountedResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessUnmountedResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessUnmountedResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessUnmountedResponse) {
					name = jsonFieldsNameOfSuccessUnmountedResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessUnmountedResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessUnmountedResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessUnmountedResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessUnmountedResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Unmounted.Set {
			e.FieldStart("unmounted")
			s.Unmounted.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessUnmountedResponseData = [1]string{
	0: "unmounted",
}

// Decode decodes SuccessUnmountedResponseData from json.
func (s *SuccessUnmountedResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessUnmountedResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unmounted":
			if err := func() error {
				s.Unmounted.Reset()
				if err := s.Unmounted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unmounted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessUnmountedResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessUnmountedResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessUnmountedResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessUnmountedResponseSuccess as json.
func (s SuccessUnmountedResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessUnmountedResponseSuccess from json.
func (s *SuccessUnmountedResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessUnmountedResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessUnmountedResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessUnmountedResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessUnmountedResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessUserResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessUserResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessUserResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessUserResponse from json.
func (s *SuccessUserResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessUserResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessUserResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessUserResponse) {
					name = jsonFieldsNameOfSuccessUserResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessUserResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessUserResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessUserResponseSuccess as json.
func (s SuccessUserResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessUserResponseSuccess from json.
func (s *SuccessUserResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessUserResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessUserResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessUserResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessUserResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessWrittenResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessWrittenResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("success")
		s.Success.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessWrittenResponse = [2]string{
	0: "success",
	1: "data",
}

// Decode decodes SuccessWrittenResponse from json.
func (s *SuccessWrittenResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessWrittenResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "success":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessWrittenResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSuccessWrittenResponse) {
					name = jsonFieldsNameOfSuccessWrittenResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessWrittenResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessWrittenResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SuccessWrittenResponseData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SuccessWrittenResponseData) encodeFields(e *jx.Encoder) {
	{
		if s.Written.Set {
			e.FieldStart("written")
			s.Written.Encode(e)
		}
	}
}

var jsonFieldsNameOfSuccessWrittenResponseData = [1]string{
	0: "written",
}

// Decode decodes SuccessWrittenResponseData from json.
func (s *SuccessWrittenResponseData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessWrittenResponseData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "written":
			if err := func() error {
				s.Written.Reset()
				if err := s.Written.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"written\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SuccessWrittenResponseData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SuccessWrittenResponseData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessWrittenResponseData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SuccessWrittenResponseSuccess as json.
func (s SuccessWrittenResponseSuccess) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes SuccessWrittenResponseSuccess from json.
func (s *SuccessWrittenResponseSuccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SuccessWrittenResponseSuccess to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = SuccessWrittenResponseSuccess(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SuccessWrittenResponseSuccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SuccessWrittenResponseSuccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Team) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Team) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		if s.OwnerID.Set {
			e.FieldStart("owner_id")
			s.OwnerID.Encode(e)
		}
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfTeam = [6]string{
	0: "id",
	1: "name",
	2: "slug",
	3: "owner_id",
	4: "created_at",
	5: "updated_at",
}

// Decode decodes Team from json.
func (s *Team) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Team to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "owner_id":
			if err := func() error {
				s.OwnerID.Reset()
				if err := s.OwnerID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"owner_id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Team")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeam) {
					name = jsonFieldsNameOfTeam[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Team) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Team) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
	{
		e.FieldStart("role")
		e.Str(s.Role)
	}
	{
		e.FieldStart("joined_at")
		json.EncodeDateTime(e, s.JoinedAt)
	}
}

var jsonFieldsNameOfTeamMember = [5]string{
	0: "id",
	1: "team_id",
	2: "user_id",
	3: "role",
	4: "joined_at",
}

// Decode decodes TeamMember from json.
func (s *TeamMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "team_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Role = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "joined_at":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.JoinedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"joined_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamMember) {
					name = jsonFieldsNameOfTeamMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDDeleteForbidden as json.
func (s *TeamsIDDeleteForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDDeleteForbidden from json.
func (s *TeamsIDDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDDeleteForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDDeleteForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDDeleteNotFound as json.
func (s *TeamsIDDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDDeleteNotFound from json.
func (s *TeamsIDDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDDeleteNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDGetForbidden as json.
func (s *TeamsIDGetForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDGetForbidden from json.
func (s *TeamsIDGetForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDGetForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDGetForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDGetForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDGetForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDGetNotFound as json.
func (s *TeamsIDGetNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDGetNotFound from json.
func (s *TeamsIDGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDGetNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDGetNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDMembersPostConflict as json.
func (s *TeamsIDMembersPostConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDMembersPostConflict from json.
func (s *TeamsIDMembersPostConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDMembersPostConflict to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDMembersPostConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDMembersPostConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDMembersPostConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDMembersPostForbidden as json.
func (s *TeamsIDMembersPostForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDMembersPostForbidden from json.
func (s *TeamsIDMembersPostForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDMembersPostForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDMembersPostForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDMembersPostForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDMembersPostForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDMembersPostNotFound as json.
func (s *TeamsIDMembersPostNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDMembersPostNotFound from json.
func (s *TeamsIDMembersPostNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDMembersPostNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDMembersPostNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDMembersPostNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDMembersPostNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDMembersUserIdDeleteForbidden as json.
func (s *TeamsIDMembersUserIdDeleteForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDMembersUserIdDeleteForbidden from json.
func (s *TeamsIDMembersUserIdDeleteForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDMembersUserIdDeleteForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDMembersUserIdDeleteForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDMembersUserIdDeleteForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDMembersUserIdDeleteForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDMembersUserIdDeleteNotFound as json.
func (s *TeamsIDMembersUserIdDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDMembersUserIdDeleteNotFound from json.
func (s *TeamsIDMembersUserIdDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDMembersUserIdDeleteNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDMembersUserIdDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDMembersUserIdDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDMembersUserIdDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDMembersUserIdPutForbidden as json.
func (s *TeamsIDMembersUserIdPutForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDMembersUserIdPutForbidden from json.
func (s *TeamsIDMembersUserIdPutForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDMembersUserIdPutForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDMembersUserIdPutForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDMembersUserIdPutForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDMembersUserIdPutForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDMembersUserIdPutNotFound as json.
func (s *TeamsIDMembersUserIdPutNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDMembersUserIdPutNotFound from json.
func (s *TeamsIDMembersUserIdPutNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDMembersUserIdPutNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDMembersUserIdPutNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDMembersUserIdPutNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDMembersUserIdPutNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDPutBadRequest as json.
func (s *TeamsIDPutBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDPutBadRequest from json.
func (s *TeamsIDPutBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDPutBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDPutBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDPutBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDPutBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDPutForbidden as json.
func (s *TeamsIDPutForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDPutForbidden from json.
func (s *TeamsIDPutForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDPutForbidden to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDPutForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDPutForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDPutForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsIDPutNotFound as json.
func (s *TeamsIDPutNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsIDPutNotFound from json.
func (s *TeamsIDPutNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsIDPutNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsIDPutNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsIDPutNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsIDPutNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsPostBadRequest as json.
func (s *TeamsPostBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsPostBadRequest from json.
func (s *TeamsPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsPostBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsPostBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TeamsPostConflict as json.
func (s *TeamsPostConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes TeamsPostConflict from json.
func (s *TeamsPostConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamsPostConflict to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TeamsPostConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamsPostConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamsPostConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Template) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Template) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("template_id")
		e.Str(s.TemplateID)
	}
	{
		e.FieldStart("scope")
		e.Str(s.Scope)
	}
	{
		if s.TeamID.Set {
			e.FieldStart("team_id")
			s.TeamID.Encode(e)
		}
	}
	{
		if s.UserID.Set {
			e.FieldStart("user_id")
			s.UserID.Encode(e)
		}
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfTemplate = [7]string{
	0: "template_id",
	1: "scope",
	2: "team_id",
	3: "user_id",
	4: "spec",
	5: "created_at",
	6: "updated_at",
}

// Decode decodes Template from json.
func (s *Template) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Template to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TemplateID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		case "scope":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Scope = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scope\"")
			}
		case "team_id":
			if err := func() error {
				s.TeamID.Reset()
				if err := s.TeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "user_id":
			if err := func() error {
				s.UserID.Reset()
				if err := s.UserID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Template")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTemplate) {
					name = jsonFieldsNameOfTemplate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Template) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Template) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplateCreateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplateCreateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("template_id")
		e.Str(s.TemplateID)
	}
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
}

var jsonFieldsNameOfTemplateCreateRequest = [2]string{
	0: "template_id",
	1: "spec",
}

// Decode decodes TemplateCreateRequest from json.
func (s *TemplateCreateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateCreateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TemplateID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template_id\"")
			}
		case "spec":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplateCreateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTemplateCreateRequest) {
					name = jsonFieldsNameOfTemplateCreateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplateCreateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateCreateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TemplateUpdateRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TemplateUpdateRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("spec")
		s.Spec.Encode(e)
	}
}

var jsonFieldsNameOfTemplateUpdateRequest = [1]string{
	0: "spec",
}

// Decode decodes TemplateUpdateRequest from json.
func (s *TemplateUpdateRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateUpdateRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "spec":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Spec.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spec\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TemplateUpdateRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTemplateUpdateRequest) {
					name = jsonFieldsNameOfTemplateUpdateRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TemplateUpdateRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateUpdateRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Toleration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Toleration) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Operator.Set {
			e.FieldStart("operator")
			s.Operator.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.Effect.Set {
			e.FieldStart("effect")
			s.Effect.Encode(e)
		}
	}
}

var jsonFieldsNameOfToleration = [4]string{
	0: "key",
	1: "operator",
	2: "value",
	3: "effect",
}

// Decode decodes Toleration from json.
func (s *Toleration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Toleration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "operator":
			if err := func() error {
				s.Operator.Reset()
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "effect":
			if err := func() error {
				s.Effect.Reset()
				if err := s.Effect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"effect\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Toleration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Toleration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Toleration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TplSandboxNetworkPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TplSandboxNetworkPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("mode")
		s.Mode.Encode(e)
	}
	{
		if s.Egress.Set {
			e.FieldStart("egress")
			s.Egress.Encode(e)
		}
	}
}

var jsonFieldsNameOfTplSandboxNetworkPolicy = [2]string{
	0: "mode",
	1: "egress",
}

// Decode decodes TplSandboxNetworkPolicy from json.
func (s *TplSandboxNetworkPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TplSandboxNetworkPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mode":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "egress":
			if err := func() error {
				s.Egress.Reset()
				if err := s.Egress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"egress\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TplSandboxNetworkPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTplSandboxNetworkPolicy) {
					name = jsonFieldsNameOfTplSandboxNetworkPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TplSandboxNetworkPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TplSandboxNetworkPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TplSandboxNetworkPolicyMode as json.
func (s TplSandboxNetworkPolicyMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TplSandboxNetworkPolicyMode from json.
func (s *TplSandboxNetworkPolicyMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TplSandboxNetworkPolicyMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TplSandboxNetworkPolicyMode(v) {
	case TplSandboxNetworkPolicyModeAllowAll:
		*s = TplSandboxNetworkPolicyModeAllowAll
	case TplSandboxNetworkPolicyModeBlockAll:
		*s = TplSandboxNetworkPolicyModeBlockAll
	default:
		*s = TplSandboxNetworkPolicyMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TplSandboxNetworkPolicyMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TplSandboxNetworkPolicyMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnmountRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnmountRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("sandboxvolume_id")
		e.Str(s.SandboxvolumeID)
	}
}

var jsonFieldsNameOfUnmountRequest = [1]string{
	0: "sandboxvolume_id",
}

// Decode decodes UnmountRequest from json.
func (s *UnmountRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnmountRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sandboxvolume_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SandboxvolumeID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sandboxvolume_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnmountRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUnmountRequest) {
					name = jsonFieldsNameOfUnmountRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnmountRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnmountRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExposedPortsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExposedPortsRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ports")
		e.ArrStart()
		for _, elem := range s.Ports {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateExposedPortsRequest = [1]string{
	0: "ports",
}

// Decode decodes UpdateExposedPortsRequest from json.
func (s *UpdateExposedPortsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExposedPortsRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ports":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Ports = make([]ExposedPortConfig, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExposedPortConfig
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Ports = append(s.Ports, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExposedPortsRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateExposedPortsRequest) {
					name = jsonFieldsNameOfUpdateExposedPortsRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExposedPortsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExposedPortsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTeamMemberRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTeamMemberRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
}

var jsonFieldsNameOfUpdateTeamMemberRequest = [1]string{
	0: "role",
}

// Decode decodes UpdateTeamMemberRequest from json.
func (s *UpdateTeamMemberRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTeamMemberRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTeamMemberRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTeamMemberRequest) {
					name = jsonFieldsNameOfUpdateTeamMemberRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTeamMemberRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTeamMemberRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTeamMemberRequestRole as json.
func (s UpdateTeamMemberRequestRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTeamMemberRequestRole from json.
func (s *UpdateTeamMemberRequestRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTeamMemberRequestRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTeamMemberRequestRole(v) {
	case UpdateTeamMemberRequestRoleAdmin:
		*s = UpdateTeamMemberRequestRoleAdmin
	case UpdateTeamMemberRequestRoleDeveloper:
		*s = UpdateTeamMemberRequestRoleDeveloper
	case UpdateTeamMemberRequestRoleViewer:
		*s = UpdateTeamMemberRequestRoleViewer
	default:
		*s = UpdateTeamMemberRequestRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTeamMemberRequestRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTeamMemberRequestRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTeamRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTeamRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTeamRequest = [2]string{
	0: "name",
	1: "slug",
}

// Decode decodes UpdateTeamRequest from json.
func (s *UpdateTeamRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTeamRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTeamRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTeamRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTeamRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.DefaultTeamID.Set {
			e.FieldStart("default_team_id")
			s.DefaultTeamID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateUserRequest = [3]string{
	0: "name",
	1: "avatar_url",
	2: "default_team_id",
}

// Decode decodes UpdateUserRequest from json.
func (s *UpdateUserRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "default_team_id":
			if err := func() error {
				s.DefaultTeamID.Reset()
				if err := s.DefaultTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_team_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.AvatarURL.Set {
			e.FieldStart("avatar_url")
			s.AvatarURL.Encode(e)
		}
	}
	{
		if s.DefaultTeamID.Set {
			e.FieldStart("default_team_id")
			s.DefaultTeamID.Encode(e)
		}
	}
	{
		e.FieldStart("email_verified")
		e.Bool(s.EmailVerified)
	}
	{
		e.FieldStart("is_admin")
		e.Bool(s.IsAdmin)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUser = [9]string{
	0: "id",
	1: "email",
	2: "name",
	3: "avatar_url",
	4: "default_team_id",
	5: "email_verified",
	6: "is_admin",
	7: "created_at",
	8: "updated_at",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "avatar_url":
			if err := func() error {
				s.AvatarURL.Reset()
				if err := s.AvatarURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "default_team_id":
			if err := func() error {
				s.DefaultTeamID.Reset()
				if err := s.DefaultTeamID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default_team_id\"")
			}
		case "email_verified":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.EmailVerified = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email_verified\"")
			}
		case "is_admin":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsAdmin = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_admin\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11100111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersMeIdentitiesIDDeleteBadRequest as json.
func (s *UsersMeIdentitiesIDDeleteBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersMeIdentitiesIDDeleteBadRequest from json.
func (s *UsersMeIdentitiesIDDeleteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersMeIdentitiesIDDeleteBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersMeIdentitiesIDDeleteBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersMeIdentitiesIDDeleteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersMeIdentitiesIDDeleteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersMeIdentitiesIDDeleteNotFound as json.
func (s *UsersMeIdentitiesIDDeleteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersMeIdentitiesIDDeleteNotFound from json.
func (s *UsersMeIdentitiesIDDeleteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersMeIdentitiesIDDeleteNotFound to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersMeIdentitiesIDDeleteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersMeIdentitiesIDDeleteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersMeIdentitiesIDDeleteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersMeIdentitiesIDDeleteUnauthorized as json.
func (s *UsersMeIdentitiesIDDeleteUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersMeIdentitiesIDDeleteUnauthorized from json.
func (s *UsersMeIdentitiesIDDeleteUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersMeIdentitiesIDDeleteUnauthorized to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersMeIdentitiesIDDeleteUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersMeIdentitiesIDDeleteUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersMeIdentitiesIDDeleteUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersMePutBadRequest as json.
func (s *UsersMePutBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersMePutBadRequest from json.
func (s *UsersMePutBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersMePutBadRequest to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersMePutBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersMePutBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersMePutBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UsersMePutUnauthorized as json.
func (s *UsersMePutUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorEnvelope)(s)

	unwrapped.Encode(e)
}

// Decode decodes UsersMePutUnauthorized from json.
func (s *UsersMePutUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersMePutUnauthorized to nil")
	}
	var unwrapped ErrorEnvelope
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UsersMePutUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersMePutUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersMePutUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VolumeAccessMode as json.
func (s VolumeAccessMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VolumeAccessMode from json.
func (s *VolumeAccessMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolumeAccessMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VolumeAccessMode(v) {
	case VolumeAccessModeRWO:
		*s = VolumeAccessModeRWO
	case VolumeAccessModeROX:
		*s = VolumeAccessModeROX
	case VolumeAccessModeRWX:
		*s = VolumeAccessModeRWX
	default:
		*s = VolumeAccessMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VolumeAccessMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolumeAccessMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VolumeConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VolumeConfig) encodeFields(e *jx.Encoder) {
	{
		if s.CacheSize.Set {
			e.FieldStart("cache_size")
			s.CacheSize.Encode(e)
		}
	}
	{
		if s.Prefetch.Set {
			e.FieldStart("prefetch")
			s.Prefetch.Encode(e)
		}
	}
	{
		if s.BufferSize.Set {
			e.FieldStart("buffer_size")
			s.BufferSize.Encode(e)
		}
	}
	{
		if s.Writeback.Set {
			e.FieldStart("writeback")
			s.Writeback.Encode(e)
		}
	}
}

var jsonFieldsNameOfVolumeConfig = [4]string{
	0: "cache_size",
	1: "prefetch",
	2: "buffer_size",
	3: "writeback",
}

// Decode decodes VolumeConfig from json.
func (s *VolumeConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VolumeConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cache_size":
			if err := func() error {
				s.CacheSize.Reset()
				if err := s.CacheSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cache_size\"")
			}
		case "prefetch":
			if err := func() error {
				s.Prefetch.Reset()
				if err := s.Prefetch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefetch\"")
			}
		case "buffer_size":
			if err := func() error {
				s.BufferSize.Reset()
				if err := s.BufferSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buffer_size\"")
			}
		case "writeback":
			if err := func() error {
				s.Writeback.Reset()
				if err := s.Writeback.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeback\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VolumeConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VolumeConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VolumeConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WebhookConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WebhookConfig) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.WatchDir.Set {
			e.FieldStart("watch_dir")
			s.WatchDir.Encode(e)
		}
	}
}

var jsonFieldsNameOfWebhookConfig = [3]string{
	0: "url",
	1: "secret",
	2: "watch_dir",
}

// Decode decodes WebhookConfig from json.
func (s *WebhookConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WebhookConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "watch_dir":
			if err := func() error {
				s.WatchDir.Reset()
				if err := s.WatchDir.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"watch_dir\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WebhookConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WebhookConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WebhookConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WeightedPodAffinityTerm) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WeightedPodAffinityTerm) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("weight")
		e.Int32(s.Weight)
	}
	{
		e.FieldStart("podAffinityTerm")
		s.PodAffinityTerm.Encode(e)
	}
}

var jsonFieldsNameOfWeightedPodAffinityTerm = [2]string{
	0: "weight",
	1: "podAffinityTerm",
}

// Decode decodes WeightedPodAffinityTerm from json.
func (s *WeightedPodAffinityTerm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WeightedPodAffinityTerm to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "weight":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Weight = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		case "podAffinityTerm":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.PodAffinityTerm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"podAffinityTerm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WeightedPodAffinityTerm")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWeightedPodAffinityTerm) {
					name = jsonFieldsNameOfWeightedPodAffinityTerm[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WeightedPodAffinityTerm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WeightedPodAffinityTerm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
